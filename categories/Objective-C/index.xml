<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Objective-C on AuTopTr</title><link>https://autoptr.top/categories/Objective-C/</link><description>Recent content in Objective-C on AuTopTr</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 03 Jun 2019 08:08:08 +0800</lastBuildDate><atom:link href="https://autoptr.top/categories/Objective-C/index.xml" rel="self" type="application/rss+xml"/><item><title>Tutorials - All credit to github.com/NSHipster</title><link>https://autoptr.top/tutorials/NSHipster/</link><pubDate>Mon, 03 Jun 2019 08:08:08 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/</guid><description>[Tutorials,教程]&lt;br />Tutorials,教程</description></item><item><title>Reader Submissions - New Year's 2015</title><link>https://autoptr.top/tutorials/NSHipster/2015-01-01-new-years-2015/</link><pubDate>Thu, 01 Jan 2015 09:32:29 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/2015-01-01-new-years-2015/</guid><description>对专业的苹果开发者来说，2014 年是一个令人难以置信的一年。随着大量新发展的出现，无论是从苹果还是整个社区，都为读者分享了很多的有趣花絮。&lt;br />[Reader Submissions - New Year's 2015,macOS,C++,Cocoa,Objective-C,Swift,NSHipster]&lt;br />Reader Submissions - New Year's 2015,macOS,C++,Cocoa,Objective-C,Swift,NSHipster</description></item><item><title>Clang Diagnostics</title><link>https://autoptr.top/tutorials/NSHipster/2014-06-16-clang-diagnostics/</link><pubDate>Mon, 16 Jun 2014 09:32:29 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/2014-06-16-clang-diagnostics/</guid><description>诊断结合了逻辑与分析来得出一个结论。这是最纯粹的科学和工程学，也是人类最有力的推理。对于我们开发者来说，我们通过代码通知后续代码的生产，创建了一个在过去半个世纪里呈几何级数发展的技术的正反馈循环。尤其对于我们的 Objective-C 开发者来说，最有效的诊断来自 Clang。&lt;br />[Clang Diagnostics,macOS,C++,Cocoa,Objective-C,Swift,NSHipster]&lt;br />Clang Diagnostics,macOS,C++,Cocoa,Objective-C,Swift,NSHipster</description></item><item><title>Benchmarking</title><link>https://autoptr.top/tutorials/NSHipster/2014-05-19-benchmarking/</link><pubDate>Mon, 19 May 2014 09:32:29 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/2014-05-19-benchmarking/</guid><description>对于完成有意义的工作来说抽象很重要，但却会带来副作用。利用benchmarking，工程师可以揭开他们代码中运行效率的面纱，然后利用获得的信息来优化。&lt;br />[Benchmarking,macOS,C++,Cocoa,Objective-C,Swift,NSHipster]&lt;br />Benchmarking,macOS,C++,Cocoa,Objective-C,Swift,NSHipster</description></item><item><title>namespacing</title><link>https://autoptr.top/tutorials/NSHipster/2014-02-24-namespacing/</link><pubDate>Mon, 24 Feb 2014 09:32:29 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/2014-02-24-namespacing/</guid><description>命名一直是Objective-C的硬伤，和那些优雅的语言相比，Objective-C缺乏标识符容器这点引来了很多不切实际的批评家。&lt;br />[namespacing,macOS,C++,Cocoa,Objective-C,Swift,NSHipster]&lt;br />namespacing,macOS,C++,Cocoa,Objective-C,Swift,NSHipster</description></item><item><title>Method Swizzling</title><link>https://autoptr.top/tutorials/NSHipster/2014-02-17-method-swizzling/</link><pubDate>Mon, 17 Feb 2014 09:32:29 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/2014-02-17-method-swizzling/</guid><description>Method swizzling 用来改变已存在的 selector 映射的方法实现。Method swizzling 通过在运行时修改类的消息分发列表中 selector 与实现的映射使得在运行时修改方法的调用成为可能。&lt;br />[Method Swizzling,macOS,C++,Cocoa,Objective-C,Swift,NSHipster]&lt;br />Method Swizzling,macOS,C++,Cocoa,Objective-C,Swift,NSHipster</description></item><item><title>Associated Objects</title><link>https://autoptr.top/tutorials/NSHipster/2014-02-10-associated-objects/</link><pubDate>Mon, 10 Feb 2014 09:32:29 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/2014-02-10-associated-objects/</guid><description>对象关联是Objective-C 2.0在运行时的新特性，这个特性允许你将任何键值在运行时关联到对象上。对象关联是黑暗符咒一样，应该和其他来自objc/runtime.h的函数一样被小心谨慎地对待&lt;br />[Associated Objects,macOS,C++,Cocoa,Objective-C,Swift,NSHipster]&lt;br />Associated Objects,macOS,C++,Cocoa,Objective-C,Swift,NSHipster</description></item><item><title>Extended File Attributes</title><link>https://autoptr.top/tutorials/NSHipster/2014-01-20-extended-file-attributes/</link><pubDate>Mon, 20 Jan 2014 09:32:29 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/2014-01-20-extended-file-attributes/</guid><description>在 NSA 披露的间谍活动中，在大众的关注下，元数据的概念在政府监控中担当了意想不到的角色。它是什么？它揭示了我们的什么信息和哪些日常习惯？这些是美国人民都在问的问题，他们需要一个答案。&lt;br />[Extended File Attributes,macOS,C++,Cocoa,Objective-C,Swift,NSHipster]&lt;br />Extended File Attributes,macOS,C++,Cocoa,Objective-C,Swift,NSHipster</description></item><item><title>Equality</title><link>https://autoptr.top/tutorials/NSHipster/2013-08-26-equality/</link><pubDate>Mon, 26 Aug 2013 09:32:29 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/2013-08-26-equality/</guid><description>在哲学和数学领域，相等的概念一直以来都是人们所争论和探寻的焦点，其所蕴含的深层含义更是延伸到道德，社会正义以及公共政策等诸多层面。对于程序员来说，在我们所建模的问题领域当中，协调好“相等”概念在逻辑上和实际意义上的理解，是一个很重要的任务。&lt;br />[Equality,macOS,C++,Cocoa,Objective-C,Swift,NSHipster]&lt;br />Equality,macOS,C++,Cocoa,Objective-C,Swift,NSHipster</description></item><item><title>rand(3) / random(3) / arc4random(3) / et al.</title><link>https://autoptr.top/tutorials/NSHipster/2013-08-12-random/</link><pubDate>Mon, 12 Aug 2013 09:32:29 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/2013-08-12-random/</guid><description>所谓的随机性只是潜在的因果关系。当然，应用程序开发人员可以不关心哲学，他们关心的是代码。因此，我们本周的目标：清理所有长期以来在 Objective-C 中与随机有关的问题和误解&lt;br />[rand(3) / random(3) / arc4random(3) / et al.,macOS,C++,Cocoa,Objective-C,Swift,NSHipster]&lt;br />rand(3) / random(3) / arc4random(3) / et al.,macOS,C++,Cocoa,Objective-C,Swift,NSHipster</description></item><item><title>Documentation</title><link>https://autoptr.top/tutorials/NSHipster/2013-08-05-documentation/</link><pubDate>Mon, 05 Aug 2013 09:32:29 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/2013-08-05-documentation/</guid><description>Cocoa 开发者间流传着一句格言，Objective-C 的冗长使得其代码就是有效的自我说明。有了 longMethodNamesWithNamedParameters: 以及参数的显式类型，Objective-C 的方法不会给人留下太多的想象空间。&lt;br />[Documentation,macOS,C++,Cocoa,Objective-C,Swift,NSHipster]&lt;br />Documentation,macOS,C++,Cocoa,Objective-C,Swift,NSHipster</description></item><item><title>对象下标索引</title><link>https://autoptr.top/tutorials/NSHipster/2013-06-17-object-subscripting/</link><pubDate>Mon, 17 Jun 2013 09:32:29 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/2013-06-17-object-subscripting/</guid><description>[对象下标索引,macOS,C++,Cocoa,Objective-C,Swift,NSHipster]&lt;br />对象下标索引,macOS,C++,Cocoa,Objective-C,Swift,NSHipster</description></item><item><title>BOOL / bool / Boolean / NSCFBoolean</title><link>https://autoptr.top/tutorials/NSHipster/2013-04-08-bool/</link><pubDate>Mon, 08 Apr 2013 09:32:29 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/2013-04-08-bool/</guid><description>再一次，将我们有逻辑的世界编码为冰冷的电脑计算字节码使得我们不得不用这样或那样的方法处理这些问题。同时，通过阅读我们关于Objective-C中布尔值及其同类的讨论，你会发现，真相实在是比小说还离奇。&lt;br />[BOOL / bool / Boolean / NSCFBoolean,macOS,C++,Cocoa,Objective-C,Swift,NSHipster]&lt;br />BOOL / bool / Boolean / NSCFBoolean,macOS,C++,Cocoa,Objective-C,Swift,NSHipster</description></item><item><title>C Storage Classes</title><link>https://autoptr.top/tutorials/NSHipster/2013-03-18-c-storage-classes/</link><pubDate>Mon, 18 Mar 2013 09:32:29 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/2013-03-18-c-storage-classes/</guid><description>在 C 语言中，程序中的变量或函数的作用域和生存周期是由它的存储类确定的。了解这些存储类能帮助我们解密整个 Objective-C 中都常见的术语&lt;br />[C Storage Classes,macOS,C++,Cocoa,Objective-C,Swift,NSHipster]&lt;br />C Storage Classes,macOS,C++,Cocoa,Objective-C,Swift,NSHipster</description></item><item><title>Type Encodings</title><link>https://autoptr.top/tutorials/NSHipster/2013-02-04-type-encodings/</link><pubDate>Mon, 04 Feb 2013 09:32:29 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/2013-02-04-type-encodings/</guid><description>从数字电台和数学命理到象形文字和流浪汉码，找到看似平常的东西中隐藏的意思真是令人着迷。即使它们中隐藏的信息很少用到或者并不特别有趣，但正是那种寻找的快感激发着我们强烈的好奇心。&lt;br />[Type Encodings,macOS,C++,Cocoa,Objective-C,Swift,NSHipster]&lt;br />Type Encodings,macOS,C++,Cocoa,Objective-C,Swift,NSHipster</description></item><item><title>__attribute__</title><link>https://autoptr.top/tutorials/NSHipster/2013-01-14-__attribute__/</link><pubDate>Mon, 14 Jan 2013 09:32:29 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/2013-01-14-__attribute__/</guid><description>本站点文章经常中出现的一个主题是，强调和编译器保持良好关系的重要性。和其他手艺一样，程序员的效率也取决于如何对待他们的工具。照顾好你的工具，它们也会照顾好你。&lt;br />[__attribute__,macOS,C++,Cocoa,Objective-C,Swift,NSHipster]&lt;br />__attribute__,macOS,C++,Cocoa,Objective-C,Swift,NSHipster</description></item><item><title>nil / Nil / NULL / NSNull</title><link>https://autoptr.top/tutorials/NSHipster/2013-01-07-nil/</link><pubDate>Mon, 07 Jan 2013 09:32:29 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/2013-01-07-nil/</guid><description>[nil / Nil / NULL / NSNull,macOS,C++,Cocoa,Objective-C,Swift,NSHipster]&lt;br />nil / Nil / NULL / NSNull,macOS,C++,Cocoa,Objective-C,Swift,NSHipster</description></item><item><title>instancetype</title><link>https://autoptr.top/tutorials/NSHipster/2012-12-10-instancetype/</link><pubDate>Mon, 10 Dec 2012 09:32:29 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/2012-12-10-instancetype/</guid><description>Objective-C 是一门正迅速发展的语言，这种发展速度在别的现有语言中是不曾有过的。从普通到范例转变的发展，真要说清它们之间的差异还得慢慢来。因为我们正在讨论的是底层语言的特性，对于API设计的更深层含义还比较难理解。&lt;br />[instancetype,macOS,C++,Cocoa,Objective-C,Swift,NSHipster]&lt;br />instancetype,macOS,C++,Cocoa,Objective-C,Swift,NSHipster</description></item><item><title>@</title><link>https://autoptr.top/tutorials/NSHipster/2012-10-08-at-compiler-directives/</link><pubDate>Mon, 08 Oct 2012 09:32:29 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/2012-10-08-at-compiler-directives/</guid><description>所以如果我们要对这难以捉摸的 Objective-C 品种观“码”，我们要看些什么？方括号，长的荒唐的方法名，和 &lt;tt>@&lt;/tt> 指令。"at" 符号编译器指令对于理解 Objective-C 的格式以及其起源和底层机制非常重要。它是使得 Objective-C 如此强大，具有表现力，并仍能一路编译成底层 C 语言的关键。&lt;br />[@,macOS,C++,Cocoa,Objective-C,Swift,NSHipster]&lt;br />@,macOS,C++,Cocoa,Objective-C,Swift,NSHipster</description></item><item><title>#pragma</title><link>https://autoptr.top/tutorials/NSHipster/2012-10-01-pragma/</link><pubDate>Mon, 01 Oct 2012 09:32:29 +0800</pubDate><guid>https://autoptr.top/tutorials/NSHipster/2012-10-01-pragma/</guid><description>#pragma 声明是彰显Objective-C工艺的标志之一。虽然 #pragma最初的目的是为了使得源代码在不同的编译器下兼容的，但精明的 Xcode 编码器将 #pragma 使用到了极致。&lt;br />[#pragma,macOS,C++,Cocoa,Objective-C,Swift,NSHipster]&lt;br />#pragma,macOS,C++,Cocoa,Objective-C,Swift,NSHipster</description></item></channel></rss>