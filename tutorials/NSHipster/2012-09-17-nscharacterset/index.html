<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>NSCharacterSet</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="NSCharacterSet,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="NSCharacterSet,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>NSCharacterSet</span><span class=btRight><span title="Author · 作者" class=author>Mattt</span> <span title="Translator · 翻译" class=author>Ricky Tan</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p>正如<a href=https://nshipster.com/cfstringtransform/>之前</a>提前过的，基础类库（Foundation）拥有最好的、功能也最全的string类的实现。</p><p>但是仅当程序员熟练掌握它时，一个string的实现才是真的好。所以本周，我们将浏览一些基础类库的string生态系统中经常用到且用错的重要组成部分：<code>NSCharacterSet</code>。</p><hr><blockquote><p>如果你对什么是字符编码搞不清楚的话（即使你有很好的专业知识），那么你应该抓住这次机会反复阅读Joel Spolsky的这篇经典的文章<a href=http://www.joelonsoftware.com/articles/Unicode.html>&ldquo;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&rdquo;</a>。在头脑中保持新鲜感将对你理解我们将要探讨的话题非常有帮助。</p></blockquote><p><code>NSCharacterSet</code> ，以及它的可变版本<code>NSMutableCharacterSet</code>，用面向对象的方式来表示一组Unicode字符。它经常与<code>NSString</code>及<code>NSScanner</code>组合起来使用，在不同的字符上做过滤、删除或者分割操作。为了给你提供这些字符是哪些字符的直观印象，请看看<code>NSCharacterSet</code> 提供的类方法：</p><ul><li><code>alphanumericCharacterSet</code></li><li><code>capitalizedLetterCharacterSet</code></li><li><code>controlCharacterSet</code></li><li><code>decimalDigitCharacterSet</code></li><li><code>decomposableCharacterSet</code></li><li><code>illegalCharacterSet</code></li><li><code>letterCharacterSet</code></li><li><code>lowercaseLetterCharacterSet</code></li><li><code>newlineCharacterSet</code></li><li><code>nonBaseCharacterSet</code></li><li><code>punctuationCharacterSet</code></li><li><code>symbolCharacterSet</code></li><li><code>uppercaseLetterCharacterSet</code></li><li><code>whitespaceAndNewlineCharacterSet</code></li><li><code>whitespaceCharacterSet</code></li></ul><p>与它的名字所表述的相反，<code>NSCharacterSet</code> 跟 <code>NSSet</code> 一点关系都_没有_。</p><p>虽然底层实现不太一样，但是 <code>NSCharacterSet</code> 在概念上跟 <code>NSIndexSet</code> 还_有点_相似的。<code>NSIndexSet</code>，<a href=https://nshipster.cn/nsindexset/>之前</a>提到过，表示一个有序的不重复的无符号整数的集合。Unicode字符跟无符号整数类似，大致对应一些拼写表示。所以，一个 <code>NSCharacterSet +lowercaseCharacterSet</code> 字符集与一个包含97到122范围的 <code>NSIndexSet</code> 是等价的。</p><p>现在我们对理解 <code>NSCharacterSet</code> 的基本概念已经有了少许自信，让我们来看一些它的模式与反模式吧：</p><h2 id=去掉空格>去掉空格</h2><p><code>NSString -stringByTrimmingCharactersInSet:</code> 是个你需要牢牢记住的方法。它经常会传入 <code>NSCharacterSet +whitespaceCharacterSet</code> 或 <code>+whitespaceAndNewlineCharacterSet</code> 来删除输入字符串的头尾的空白符号。</p><p>需要重点注意的是，这个方法 <em>仅仅</em> 去除了 <em>开头</em> 和 <em>结尾</em> 的指定字符集中连续字符。这就是说，如果你想去除单词之间的额外空格，请看下一步。</p><h2 id=挤压空格>挤压空格</h2><p>假设你去掉字符串两端的多余空格之后，还想去除单词之间的多余空格，这里有个非常简便的方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSString <span style=color:#f92672>*</span>string <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;Lorem    ipsum dolar   sit  amet.&#34;</span>;
</span></span><span style=display:flex><span>string <span style=color:#f92672>=</span> [string stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>NSArray <span style=color:#f92672>*</span>components <span style=color:#f92672>=</span> [string componentsSeparatedByCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
</span></span><span style=display:flex><span>components <span style=color:#f92672>=</span> [components filteredArrayUsingPredicate:[NSPredicate predicateWithFormat:<span style=color:#e6db74>@&#34;self &lt;&gt; &#39;&#39;&#34;</span>]];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>string <span style=color:#f92672>=</span> [components componentsJoinedByString:<span style=color:#e6db74>@&#34; &#34;</span>];
</span></span></code></pre></div><p>首先，删除字符串首尾的空格；然后用 <code>NSString -componentsSeparatedByCharactersInSet:</code> 在空格处将字符串分割成一个 <code>NSArray</code>；再用一个 <code>NSPredicate</code> 去除空串；最后，用 <code>NSArray -componentsJoinedByString:</code> 用单个空格符将数组重新拼成字符串。注意：这种方法仅适用于英语这种用空格分割的语言。</p><p>现在看看反模式吧。请先看看 <a href=http://stackoverflow.com/questions/758212/how-can-i-strip-all-the-whitespaces-from-a-string-in-objective-c>the answers to this question on StackOverflow</a>。</p><p>在写这篇文章的时候，排行第二的正确答案有 58 个顶和 2 个踩。排行第一的有 84 个顶和 24 个踩。</p><p>如今，排名第一的答案却不是正确答案是不太正常的，但是这个问题已经破了不重复答案数（10个）的记录，同时也破了不重复、完全错误的答案数（9个）的记录。</p><p>言归正传，这里有 9 个错误答案：</p><ul><li>&ldquo;Use <code>stringByTrimmingCharactersInSet</code>&rdquo; - <em>正如你所知道的，它只去掉首尾的空格。</em></li><li>&ldquo;Replace &rsquo; &rsquo; with &lsquo;&rsquo;&rdquo; - <em>这个去除了<strong>所有</strong>的空格，劳而无功。</em></li><li>&ldquo;Use a regular expression&rdquo; - <em>有点用，但它没有处理首尾的空格。用正则表达式有点大材小用了。</em></li><li>&ldquo;Use Regexp Lite&rdquo; - <em>说真的，正则表达式真心没必要。同时为了这点功能增加第三方库很不值。</em></li><li>&ldquo;Use OgreKit&rdquo; - <em>同上，添加了第三方库。</em></li><li>&ldquo;Split the string into components, iterate over them to find components with non-zero length, and then re-combine&rdquo; - <em>很接近了，但是 <code>componentsSeparatedByCharactersInSet:</code> 已经让遍历变得没必要。</em></li><li>&ldquo;Replace two-space strings with single-space strings in a while loop&rdquo; - <em>错误且浪费计算资源。</em></li><li>&ldquo;Manually iterate over each <code>unichar</code> in the string and use <code>NSCharacterSet -characterIsMember:</code>&rdquo; - <em>用了一个复杂到让人吃惊的程度的方法，却忘了标准库中已经有方法可以用。</em></li><li>&ldquo;Find and remove all of the tabs&rdquo; - <em>有谁提到了制表符了？不过还是谢谢了吧。</em></li></ul><p>我个人并不是想责怪回答问题的人——只是指出完成这个功能有多少种不同的方法，而这些方法有多少是完全错误的。</p><h2 id=字符串分词>字符串分词</h2><p><strong>不要用 <code>NSCharacterSet</code> 来分词。</strong>
<strong>用 <code>CFStringTokenizer</code> 来替代它。</strong></p><p>你用 <code>componentsSeparatedByCharactersInSet:</code> 来清理用户输入是可以谅解的，但是用它来做更复杂的事情，你将陷入痛苦的深渊。</p><p>为什么？请记住，语言并不是都用空格作为词的分界。虽然实际上以空格分界的语言使用非常广泛。但哪怕只算上中国和日本就已经有十多亿人，占了世界人口总量的 16%。</p><p>……即使是用空格分隔的语言，分词也有一些模棱两可的边界条件，特别是复合词汇和标点符号。</p><p>以上只为说明：如果你想将字符串分成有意义的单词，那么请用 <code>CFStringTokenizer</code> （或者 <code>enumerateSubstringsInRange:options:usingBlock:</code>）吧。</p><h2 id=从字符串解析数据>从字符串解析数据</h2><p><code>NSScanner</code> 是个用以解析任意或半结构化的字符串的数据的类。当你为一个字符串创建一个扫描器时，你可以指定忽略哪些字符，这样可以避免那些字符以各种各样的方式被包含到解析出来的结果中。</p><p>例如，你想从这样一个字符串中解析出开门时间：</p><pre tabindex=0><code>Mon-Thurs:  8:00 - 18:00
Fri:        7:00 - 17:00
Sat-Sun:    10:00 - 15:00
</code></pre><p>你会 <code>enumerateLinesUsingBlock:</code> 并像这样用一个 <code>NSScanner</code> 来解析：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> skippedCharacters = NSMutableCharacterSet()
</span></span><span style=display:flex><span>skippedCharacters.formIntersectionWithCharacterSet(NSCharacterSet.punctuationCharacterSet())
</span></span><span style=display:flex><span>skippedCharacters.formIntersectionWithCharacterSet(NSCharacterSet.whitespaceCharacterSet())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>string.enumerateLines { (line, <span style=color:#66d9ef>_</span>) <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> scanner = NSScanner(string: line)
</span></span><span style=display:flex><span>    scanner.charactersToBeSkipped = skippedCharacters
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> startDay, endDay: NSString?
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> startHour: Int = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> startMinute: Int = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> endHour: Int = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> endMinute: Int = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    scanner.scanCharactersFromSet(NSCharacterSet.letterCharacterSet(), intoString: &amp;startDay)
</span></span><span style=display:flex><span>    scanner.scanCharactersFromSet(NSCharacterSet.letterCharacterSet(), intoString: &amp;endDay)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    scanner.scanInteger(&amp;startHour)
</span></span><span style=display:flex><span>    scanner.scanInteger(&amp;startMinute)
</span></span><span style=display:flex><span>    scanner.scanInteger(&amp;endHour)
</span></span><span style=display:flex><span>    scanner.scanInteger(&amp;endMinute)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSMutableCharacterSet <span style=color:#f92672>*</span>skippedCharacters <span style=color:#f92672>=</span> [NSMutableCharacterSet punctuationCharacterSet];
</span></span><span style=display:flex><span>[skippedCharacters formUnionWithCharacterSet:[NSCharacterSet whitespaceCharacterSet]];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[hours enumerateLinesUsingBlock:<span style=color:#f92672>^</span>(NSString <span style=color:#f92672>*</span>line, <span style=color:#66d9ef>BOOL</span> <span style=color:#f92672>*</span>stop) {
</span></span><span style=display:flex><span>  NSScanner <span style=color:#f92672>*</span>scanner <span style=color:#f92672>=</span> [NSScanner scannerWithString:line];
</span></span><span style=display:flex><span>  [scanner setCharactersToBeSkipped:skippedCharacters];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  NSString <span style=color:#f92672>*</span>startDay, <span style=color:#f92672>*</span>endDay;
</span></span><span style=display:flex><span>  NSUInteger startHour, startMinute, endHour, endMinute;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  [scanner scanCharactersFromSet:[NSCharacterSet letterCharacterSet] intoString:<span style=color:#f92672>&amp;</span>startDay];
</span></span><span style=display:flex><span>  [scanner scanCharactersFromSet:[NSCharacterSet letterCharacterSet] intoString:<span style=color:#f92672>&amp;</span>endDay];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  [scanner scanInteger:<span style=color:#f92672>&amp;</span>startHour];
</span></span><span style=display:flex><span>  [scanner scanInteger:<span style=color:#f92672>&amp;</span>startMinute];
</span></span><span style=display:flex><span>  [scanner scanInteger:<span style=color:#f92672>&amp;</span>endHour];
</span></span><span style=display:flex><span>  [scanner scanInteger:<span style=color:#f92672>&amp;</span>endMinute];
</span></span><span style=display:flex><span>}];
</span></span></code></pre></div><p>我们首先从空格字符集和标点符号字符集的并集构造了一个 <code>NSMutableCharacterSet</code>。告诉 <code>NSScanner</code> 忽略这些字符以极大地减少解析这些字符的必要逻辑。</p><p><code>scanCharactersFromSet:</code> 传入字母字符集得到每项中一星期内的开始和结束（可选）的天数。<code>scanInteger</code> 类似地，得到下一个连续的整型值。</p><p><code>NSCharacterSet</code> 和 <code>NSScanner</code> 让你可以快速而充满自信地编码。这两者真是完美组合。</p><hr><p><code>NSCharacterSet</code> 是基础类库中字符串处理系统中的一员，可能是最容易被用错或是误解的一员。在脑中记住这些模式与反模式，你将不仅能做一些很有用的诸如管理空格及从字符串中读信息之类的事情，更重要的是，你将避免误入歧途。</p><p>如果“不出错”对一个 NSHipster 来说不是最重要的事情，那我也不想成为正确的了！</p><blockquote><p>Ed. Speaking of (not) being wrong, the original version of this article contained errors in both code samples. These have since been corrected.</p></blockquote><pre tabindex=0><code>
---



除非&lt;a href=&#34;https://nshipster.cn/&#34; target=_blank&gt;另有声明&lt;/a&gt;，本文采用知识共享「&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/3.0/cn/&#34; target=_blank&gt;署名-非商业性使用 3.0 中国大陆&lt;/a&gt;」许可协议授权。
</code></pre><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2012-09-17 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mattt 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Cocoa target=_blank>Cocoa</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>