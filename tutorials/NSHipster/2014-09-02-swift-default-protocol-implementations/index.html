<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>Swift Default Protocol Implementations</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="Swift Default Protocol Implementations,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="Swift Default Protocol Implementations,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>Swift Default Protocol Implementations</span><span class=btRight><span title="Author · 作者" class=author>Mattt</span> <span title="Translator · 翻译" class=author>Chester Liu</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p>从 Swift 发布到现在已经过去三个月了，对于我们当中的很多人来说，Swift 的发布在整个职业生涯中都算是最令人震惊和激动的事件之一了。在这中间的几个月当中，可以说我们对于这门语言的理解和感激程度有了长足的变化。</p><p>首先是热恋期，我们所有的心思都放在外表上，专注于那些浮于表面的特性，例如 Unicode 支持（<code>let 🐶🐮</code>!）和全新的现代化的语法。仔细想想，客观上讲，就连这门语言的 <em>名字</em> 都比它的前辈要好。</p><p>几个星期之后，有了多次翻阅 Swift 指南的经历，我们开始去理解这门全新的多范式语言底层的内涵。函数式编程的狂热追随者开始支持这门语言。我们终于能够把 <code>class</code> 和 <code>struct</code> 的区别理解清楚，在这一路上也发现了一些小的技巧，例如 <a href=https://nshipster.cn/swift-operators/>自定义操作符</a> 和 <a href=https://nshipster.cn/swift-literal-convertible/>字符串可转换性</a>。所有最初的那些激动心情现在可以被转换成生产力，体现在新的应用，库和教程当中。</p><p>下周的公告标志着 iOS 和 OS X 开发者夏天的结束。是时候结束实验，开始实践了。</p><p>不过别急，我们还有几天宽裕的时间。让我们再继续学习一些知识：</p><hr><p>泛型是 Swift 的重要特性。和这门语言强大的类型系统相结合，泛型允许开发者编写出和 Objective-C 中相比更加安全，性能更高的代码，</p><p>泛型底层的机制是协议。一个 Swift 协议，和一个 Objective-C <a href=https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithProtocols/WorkingwithProtocols.html><code>@protocol</code></a> 相似，定义了需要被实现的方法和属性。</p><blockquote><p>在面向对象范式当中，类型往往和类的身份是一体的。<strong>而在 Swift 编程中，首先考虑使用 <em>协议</em> 来实现多态，其次再考虑使用继承。</strong></p></blockquote><p>不管是在 Swift 中还是 Objective-C 中，协议都有一个重要的缺陷，就是缺少内置的方法默认实现，在其他语言中这种特性可能会通过 <a href=https://en.wikipedia.org/wiki/Mixin>mixins</a> 或者 <a href=https://en.wikipedia.org/wiki/Trait_%28computer_programming%29>traits</a> 实现。</p><p>&mldr;不过故事到这里还没有结束。Swift 和它诞生时相比，多了一些 <a href=https://en.wikipedia.org/wiki/Aspect-oriented_programming>面向切面</a> 的特征。</p><p>考虑下面在标准库中被广泛使用的 <code>Equatable</code> 协议：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>protocol</span> <span style=color:#a6e22e>Equatable</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> ==(lhs: <span style=color:#66d9ef>Self</span>, rhs: <span style=color:#66d9ef>Self</span>) -&gt; Bool
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>给出一个 <code>Article</code> 结构体，其中有 <code>title</code> 和 <code>body</code> 属性，实现 <code>Equatable</code> 的方法简单直接：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Article</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> title: String
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> body: String
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Article</span>: Equatable {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> ==(lhs: Article, rhs: Article) -&gt; Bool {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> lhs.title == rhs.title <span style=color:#f92672>&amp;&amp;</span> lhs.body == rhs.body
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这些都准备就绪之后，让我们看看 <code>Equatable</code> 是如何工作的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> title = <span style=color:#e6db74>&#34;Swift Custom Operators: Syntactic Sugar or Menace to Society?&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> body = <span style=color:#e6db74>&#34;...&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> a = Article(title: title, body: body)
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> b = Article(title: title, body: body)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>a == b <span style=color:#75715e>// true</span>
</span></span><span style=display:flex><span>a <span style=color:#f92672>!=</span> b <span style=color:#75715e>// false</span>
</span></span></code></pre></div><p>等等&mldr; <code>!=</code> 是从哪里出来的？</p><p><code>!=</code> 并没有定义在 <code>Equatable</code> 协议当中，而且也肯定没有在 <code>Article</code> 中实现。到底怎么回事？</p><p><code>!=</code> 实际上是在标准库当中的这个方法里实现的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#f92672>!=&lt;</span>T : Equatable&gt;(lhs: T, rhs: T) -&gt; Bool
</span></span></code></pre></div><p>由于 <code>!=</code> 是 <code>Equatable</code> 的泛型方法，任何遵循 <code>Equatable</code> 的类型，包括 <code>Article</code>，都自动得到了使用 <code>!=</code> 操作符的能力。</p><p>如果我们想要做的话，可以重载 <code>!=</code> 的实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#f92672>!=</span>(lhs: Article, rhs: Article) -&gt; Bool {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>!</span>(lhs == rhs)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>对于相等检验来说，我们不太可能提供比 <code>==</code> 的否定检查更加高效的方法，不过这种重载在某些情况下可能是有用处的。Swift 的类型推断系统允许更加准确的声明，用于覆盖掉泛型或者隐式的对应声明。</p><p>标准库中大量使用泛型操作符，例如位运算操作：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>protocol</span> <span style=color:#a6e22e>BitwiseOperationsType</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#f92672>&amp;</span>(<span style=color:#66d9ef>_</span>: <span style=color:#66d9ef>Self</span>, <span style=color:#66d9ef>_</span>: <span style=color:#66d9ef>Self</span>) -&gt; <span style=color:#66d9ef>Self</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#f92672>|</span>(<span style=color:#66d9ef>_</span>: <span style=color:#66d9ef>Self</span>, <span style=color:#66d9ef>_</span>: <span style=color:#66d9ef>Self</span>) -&gt; <span style=color:#66d9ef>Self</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#f92672>^</span>(<span style=color:#66d9ef>_</span>: <span style=color:#66d9ef>Self</span>, <span style=color:#66d9ef>_</span>: <span style=color:#66d9ef>Self</span>) -&gt; <span style=color:#66d9ef>Self</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>prefix</span> <span style=color:#66d9ef>func</span> <span style=color:#f92672>~</span>(<span style=color:#66d9ef>_</span>: <span style=color:#66d9ef>Self</span>) -&gt; <span style=color:#66d9ef>Self</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>var</span> allZeros: <span style=color:#66d9ef>Self</span> { <span style=color:#66d9ef>get</span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当想要在已有的架构上进行扩展时，通过这种方法来实现功能，可以大幅度地减少对于模板代码的需求。</p><h2 id=方法默认实现>方法默认实现</h2><p>前面提到的技术只能用于操作符。对于协议当中的方法来说，提供默认实现相对来说要麻烦一些。</p><p>对于一个协议 <code>P</code> 来说，它有一个方法 <code>m()</code>，这个方法以一个 <code>Int</code> 作为参数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>protocol</span> <span style=color:#a6e22e>P</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>m</span>(arg: Int)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们能实现的最接近默认实现的办法，是提供一个顶层的泛型函数，它显式地接受 <code>self</code> 作为第一个参数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>protocol</span> <span style=color:#a6e22e>P</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>m</span>() <span style=color:#75715e>/* {
</span></span></span><span style=display:flex><span><span style=color:#75715e>        f(self)
</span></span></span><span style=display:flex><span><span style=color:#75715e>    }*/</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f</span>&lt;T: P&gt;(<span style=color:#66d9ef>_</span> arg: T) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>协议中注释掉的代码用于在方法实现和使用者之间进行交互。</p></blockquote><hr><p>上面这些内容都指向了 Swift 当中方法和函数之间的冲突关系。</p><p>面向对象范式所基于的思想是，对象封装状态和行为。然而在 Swift 当中，在 <code>struct</code> 或者 <code>class</code> 内部把某些泛型函数实现成方法是不可能的。</p><p>以 <code>contains</code> 方法为例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>contains</span>&lt;S : SequenceType <span style=color:#66d9ef>where</span> S.Generator.Element : Equatable&gt;(seq: S, x: S.Generator.Element) -&gt; Bool
</span></span></code></pre></div><p>因为序列生成器的元素被限定为 <code>Equatable</code>，这个方法不能被定义在泛型容器上，除非要求容器中的元素都遵循 <code>Equatable</code>。</p><p>把 <code>contains</code>，<code>advance</code> 和 <code>partition</code> 这些方法降级成顶层函数会损害标准库 。这样做不仅仅使得方法自动补全功能失效，同时还使得 API 出现了横跨面向对象和函数式编程两种范式的分裂现象。</p><p>尽管这个问题在 1.0 的时候不太可能被解决掉（同时也有很多更加紧急的事情需要解决），解决办法还是有很多的：</p><ul><li>提供 mixin 或者 trait 功能，能够对协议进行扩展，允许提供默认实现。</li><li>允许 extensions 带有泛型参数，通过类型 <code>extension Array&lt;T: Equatable></code> 这种形式来定义额外的方法，例如 <code>func contains(x: T)</code>，这个 extension 只有当有关类型满足特定条件时才可用。</li><li>在函数调用时自动把 <code>Self</code> 设置为第一个参数，使得 <code>self</code> 可以被隐式使用。</li></ul><pre tabindex=0><code>
---



除非&lt;a href=&#34;https://nshipster.cn/&#34; target=_blank&gt;另有声明&lt;/a&gt;，本文采用知识共享「&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/3.0/cn/&#34; target=_blank&gt;署名-非商业性使用 3.0 中国大陆&lt;/a&gt;」许可协议授权。
</code></pre><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2014-09-02 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mattt 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Swift target=_blank>Swift</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>