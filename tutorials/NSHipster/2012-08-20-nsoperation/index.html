<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>NSOperation</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="NSOperation,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="NSOperation,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>NSOperation</span><span class=btRight><span title="Author · 作者" class=author>Mattt</span> <span title="Translator · 翻译" class=author>Henry Lee</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p>我们都知道，让程序瞬间加载并且快速响应的秘诀在于后台异步执行任务。</p><p>现在的Objective-C开发者一般有两个选择，分别是<a href=https://en.wikipedia.org/wiki/Grand_Central_Dispatch>Grand Central Dispatch</a>或者<a href=https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/NSOperation_class/Reference/Reference.html><code>NSOperation</code></a>。现在GCD已经逐渐发展成主流了，所以我们来谈谈后者，一个面向对象的解决办法。</p><p><code>NSOperation</code>表示了一个独立的计算单元。作为一个抽象类，它给了它的子类一个十分有用而且线程安全的方式来建立状态、优先级、依赖性和取消等的模型。或者，你不是很喜欢再自己继承<code>NSOperation</code>的话，框架还提供<code>NSBlockOperation</code>，这是一个继承自<code>NSOperation</code>且封装了block的实体类。</p><p>很多执行任务类型的案例都很好的运用了<code>NSOperation</code>，包括<a href=https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLConnectionOperation.h>网络请求</a>，图像压缩，自然语言处理或者其他很多需要返回处理后数据的、可重复的、结构化的、相对长时间运行的任务。</p><p>但是仅仅把计算封装进一个对象而不做其他处理显然没有多大用处，我们还需要<code>NSOperationQueue</code>来大显身手。</p><p><code>NSOperationQueue</code>控制着这些并行操作的执行，它扮演者优先级队列的角色，让它管理的高优先级操作(<code>NSOperation -queuePriority</code>)能优先于低优先级的操作运行的情况下，使它管理的操作能基本遵循先进先出的原则执行。此外，在你设置了能并行运行的操作的最大值(<code>maxConcurrentOperationCount</code>)之后，<code>NSOperationQueue</code>还能并行执行操作。</p><p>让一个<code>NSOperation</code>操作开始，你可以直接调用<code>-start</code>，或者将它添加到<code>NSOperationQueue</code>中，添加之后，它会在队列排到它以后自动执行。</p><p>现在让我们通过怎样使用和怎样通过继承实现功能来看看<code>NSOperation</code>稍微复杂的部分。</p><h2 id=状态>状态</h2><p><code>NSOperation</code>包含了一个十分优雅的状态机来描述每一个操作的执行。</p><blockquote><p><code>isReady</code> → <code>isExecuting</code> → <code>isFinished</code></p></blockquote><p>为了替代不那么清晰的<code>state</code>属性，状态直接由上面那些keypath的KVO通知决定，也就是说，当一个操作在准备好被执行的时候，它发送了一个KVO通知给<code>isReady</code>的keypath，让这个keypath对应的属性<code>isReady</code>在被访问的时候返回<code>YES</code>。</p><p>每一个属性对于其他的属性必须是互相独立不同的，也就是同时只可能有一个属性返回<code>YES</code>，从而才能维护一个连续的状态：</p><ul><li><code>isReady</code>: 返回 <code>YES</code> 表示操作已经准备好被执行, 如果返回<code>NO</code>则说明还有其他没有先前的相关步骤没有完成。</li><li><code>isExecuting</code>: 返回<code>YES</code>表示操作正在执行，反之则没在执行。</li><li><code>isFinished</code> : 返回<code>YES</code>表示操作执行成功或者被取消了，<code>NSOperationQueue</code>只有当它管理的所有操作的<code>isFinished</code>属性全标为<code>YES</code>以后操作才停止出列，也就是队列停止运行，所以正确实现这个方法对于避免死锁很关键。</li></ul><h2 id=取消>取消</h2><p>早些取消那些没必要的操作是十分有用的。取消的原因可能包括用户的明确操作或者某个相关的操作失败。</p><p>与之前的执行状态类似，当<code>NSOperation</code>的<code>-cancel</code>状态调用的时候会通过KVO通知<code>isCancelled</code>的keypath来修改<code>isCancelled</code>属性的返回值，<code>NSOperation</code>需要尽快地清理一些内部细节，而后到达一个合适的最终状态。特别的，这个时候<code>isCancelled</code>和<code>isFinished</code>的值将是YES，而<code>isExecuting</code>的值则为NO。</p><p>有一件肯定需要注意的事情就是关于单词"cancel"的拼法特性，尽管各类英语的习惯不尽相同，但是对于<code>NSOperation</code>来说：</p><ul><li><code>cancel</code>: 方法调用里只需要一个L（动词）</li><li><code>isCancelled</code>: 属性里需要两个L（形容词）</li></ul><h2 id=优先级>优先级</h2><p>不可能所有的操作都是一样重要，通过以下的顺序设置<code>queuePriority</code>属性可以加快或者推迟操作的执行：</p><ul><li><code>NSOperationQueuePriorityVeryHigh</code></li><li><code>NSOperationQueuePriorityHigh</code></li><li><code>NSOperationQueuePriorityNormal</code></li><li><code>NSOperationQueuePriorityLow</code></li><li><code>NSOperationQueuePriorityVeryLow</code></li></ul><p>此外，有些操作还可以指定<code>threadPriority</code>的值，它的取值范围可以从<code>0.0</code>到<code>1.0</code>，<code>1.0</code>代表最高的优先级。鉴于<code>queuePriority</code>属性决定了操作执行的顺序，<code>threadPriority</code>则指定了当操作开始执行以后的CPU计算能力的分配，如果你不知道这是什么，好吧，你可能根本没必要知道这是什么。</p><h2 id=依赖性>依赖性</h2><p>根据你应用的复杂度不同，将大任务再分成一系列子任务一般都是很有意义的，而你能通过<code>NSOperation</code>的依赖性实现。</p><p>比如说，对于服务器下载并压缩一张图片的整个过程，你可能会将这个整个过程分为两个操作（可能你还会用到这个网络子过程再去下载另一张图片，然后用压缩子过程去压缩磁盘上的图片）。显然图片需要等到下载完成之后才能被调整尺寸，所以我们定义网络子操作是压缩子操作的_依赖_，通过代码来说就是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>[resizingOperation addDependency:networkingOperation];
</span></span><span style=display:flex><span>[operationQueue addOperation:networkingOperation];
</span></span><span style=display:flex><span>[operationQueue addOperation:resizingOperation];
</span></span></code></pre></div><p>除非一个操作的依赖的<code>isFinished</code>返回<code>YES</code>，不然这个操作不会开始。时时牢记将所有的依赖关系添加到操作队列很重要，不然会像走路遇到一条大沟，就走不过去了哟。</p><p>此外，确保不要意外地创建依赖循环，像A依赖B，B又依赖A，这也会导致杯具的死锁。</p><h2 id=completionblock><code>completionBlock</code></h2><p>有一个在iOS 4和Snow Leopard新加入的十分有用的功能就是<code>completionBlock</code>属性。</p><p>每当一个<code>NSOperation</code>执行完毕，它就会调用它的<code>completionBlock</code>属性一次，这提供了一个非常好的方式让你能在视图控制器(View Controller)里或者模型(Model)里加入自己更多自己的代码逻辑。比如说，你可以在一个网络请求操作的<code>completionBlock</code>来处理操作执行完以后从服务器下载下来的数据。</p><hr><p>对于现在Objective-C程序员必须掌握的工具中，<code>NSOperation</code>依然是最基本的一个。尽管GCD对于内嵌异步操作十分理想，<code>NSOperation</code>依旧提供更复杂、面向对象的计算模型，它对于涉及到各种类型数据、需要重复处理的任务又是更加理想的。在你的下一个项目里使用它吧，让它及带给用户欢乐，你自己也会很开心的。</p><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2012-08-20 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mattt 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Cocoa target=_blank>Cocoa</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>