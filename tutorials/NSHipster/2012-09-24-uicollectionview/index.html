<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>UICollectionView</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="UICollectionView,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="UICollectionView,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>UICollectionView</span><span class=btRight><span title="Author · 作者" class=author>Mattt</span> <span title="Translator · 翻译" class=author>JJ Mao</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p><code>UICollectionView</code> 是一种新的 <code>UITableView</code> ，并且它极其重要。</p><p>这并不是说，collection views是未知或模糊的&ndash;任何一个去过有关它WWDC会议的或是在 iOS 6 beta 版上玩过的人都知道怎么回事。</p><p>记住，作为一个NSHipster，不仅仅是知道名不见经传的石头，更多是在它们家喻户晓、售罄一空之前就知道有前途。所以呢，在其他人发现之前，这儿有个关于大热门的概要：</p><hr><p><code>UICollectionView</code> 采用 <code>UITableView</code> 的熟知模式，并概括了他们作出任何可能的布局 (一般情况下，这是微不足道的)。</p><p>和 <code>UITableView</code> 一样，<code>UICollectionView</code> 是管理有序items集合的 <code>UIScrollView</code> 子类。由 <em>data source</em> 管理的items在特定索引路径上提供有代表性的cell view。</p><p>然而，和 <code>UITableView</code> 不同的是，<code>UICollectionView</code> 不局限于垂直的单列布局。相反，collection view有一个 <em>layout</em> 对象，它决定子视图的位置，这类似于某些方面的data source。稍后将作详细介绍。</p><h3 id=cell-视图>Cell 视图</h3><p>在另一个不同于早期table view的做法中，视图的回收过程有明显改善。</p><p>在 <code>-tableView:cellForRowAtIndexPath:</code> 中，开发者必须调用熟悉的咒语：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>UITableViewCell <span style=color:#f92672>*</span>cell <span style=color:#f92672>=</span> [tableView dequeueReusableCellWithIdentifier:...];
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>cell) {
</span></span><span style=display:flex><span>  cell <span style=color:#f92672>=</span> [[UITableViewCell alloc] initWithStyle:... reuseIdentifier:...];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>谢天谢地，<code>UICollectionView</code> 不用这样了。如果没有可重用的cells，通过创建一个新的cell，<code>-dequeueReusableCellWithReuseIdentifier:forIndexPath:</code>确保返回一个有效对象。只需为特定的重用标识符注册一个 <code>UICollectionReusableView</code> 子类，一切都会自动工作。值得庆幸的是，iOS 6中 <code>UITableView</code> 也支持这种用法。</p><h3 id=supplementary-视图>Supplementary 视图</h3><p>由于collection views没有被归入任何特定结构，&ldquo;header&rdquo; 和 &ldquo;footer"视图的约定不是很适用。所以在它这个地方，collection views拥有可以与每个cell关联的
<em>supplementary views</em>。</p><p>每个cell可以有多个与之关联的supplementary views&ndash;每个命名为"kind&rdquo;。正因如此，headers和footers仅仅是supplementary views所施展的一成功力。</p><p>关键在于supplementary views，即使最复杂的layout也可以被实现而不影响cells的语义完整性。<code>UITableView</code> hacks对于<a href=https://en.wikipedia.org/wiki/Spacer_GIF><code>spacer.gif</code></a>就像 <code>UICollectionView</code> cells对于<a href=https://en.wikipedia.org/wiki/Semantic_HTML>semantic HTML</a>。</p><h3 id=decoration-视图>Decoration 视图</h3><p>除了cell views和supplementary views，collections还有 <em>decoration views</em>。一个decoration view，顾名思义，是一种没有功能性用途的东西&mldr; 除了在网络上传播的<a href=http://skeu.it>摒弃对anti-skeuomorphic狂热分子的仇恨</a>。不过说真的，如果你愿意给你的虚拟藏书应用镶嵌完美质感的木纹架子，这很可能是容易做到的，<em>对吗</em>？</p><p>有一点要记住的是，decoration views完全是由layout管理的，与cell或supplementary views不一样,它不在collection view data source的管辖范围内。</p><h2 id=layouts和layout属性>Layouts和Layout属性</h2><p>Layouts是使 <code>UICollectionView</code> 如此神奇的核心。把它们看作是CSS对于之前提到的collection cells的semantic HTML。</p><p><code>UICollectionViewLayout</code> 是一个抽象的基类，用于定位cell views和它们的supplementary和decoration views。但不是将它直接归入子类，大多数应用喜欢使用或者将 <code>UICollectionViewFlowLayout</code> 归入子类。Flow layouts用一些线性概念覆盖了layouts的广义类，不管它是单行或单列或一格。</p><p>在你足够安心地了解了flow layouts的所有限制之前，你可以稳妥地从flow layouts开始学习。</p><p>每个cell view、supplemental view和decoration view 都有layout属性。想要知道layouts如何灵活，只需看看 <code>UICollectionViewLayoutAttributes</code> 对象的特性就知道了：</p><ul><li><code>frame</code></li><li><code>center</code></li><li><code>size</code></li><li><code>transform3D</code></li><li><code>alpha</code></li><li><code>zIndex</code></li><li><code>hidden</code></li></ul><p>属性由你可能想要的那种委托方法指定：</p><ul><li><code>-layoutAttributesForItemAtIndexPath:</code></li><li><code>-layoutAttributesForSupplementaryViewOfKind:atIndexPath:</code></li><li><code>-layoutAttributesForDecorationViewOfKind:atIndexPath:</code></li></ul><p>这是最酷的方法：</p><ul><li><code>-layoutAttributesForElementsInRect:</code></li></ul><p>例如，你可以使用它来当items靠近屏幕边缘时淡出。或者，由于所有的layout属性特性是自动支持动画的，你可以用一套正确的3D transforms在短短几行代码里创建一个简陋的<a href=https://en.wikipedia.org/wiki/Cover_Flow>cover flow</a> layout。</p><p>实际上，collection views甚至可以大规模的交换layouts，在不改变底层数据的情况下允许视图在不同模式下无缝交换。</p><hr><p>自从有了iPad，iOS业界便弥漫着一种徘徊于原先iPhone的UI设计模式和对这种更新的、外形尺寸更大的需求之间的微妙而紧张的气氛。随着iPhone 5和"iPad mini"的传闻，要不是 <code>UICollectionView</code> (以及Auto-Layout)，这种紧张气氛可能导致整个iOS平台的衔接断裂。</p><p>Apple有无数种不同方式提供类似的功能（或者干脆不提供），但是一旦提供，他们在设计这类功能方面的确能够各个都是全垒打。</p><p>data source和layout接口之间简洁明了的逻辑分离；cell、supplementary和decoration视图之间明确的分工；一堆可继承拓展以及可通过UIKit自动实现动画的layout属性&mldr;大量的细心与智慧才组成了这些API。</p><p>因此，iOS应用的整个前景将会永远改变。有了collection views，我们的审美已经随着iPad应用的视觉和交互的整个重新定义而转变。</p><p>大家可能对collection views尚未熟悉，但是现在你可以说在它们还没流行起来之前就知道它们了。</p><blockquote><p>为了方便在你的应用里使用这个collection view的新特性，同时也不会让你感觉必须提升iOS 6的使用率才能做到这件事，这儿有一个好消息：</p></blockquote><blockquote><p><a href=https://github.com/steipete>Peter Steinberger</a> 发布了<a href=https://github.com/steipete/PSTCollectionView>PSTCollectionView</a>, <em>一个100% API-兼容的 <code>UICollectionView</code>替代物，它支持iOS 4.3+</em> 。来看看!</p></blockquote><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2012-09-24 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mattt 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Cocoa target=_blank>Cocoa</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>