<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>NSTemporaryDirectory / NSItemReplacementDirectory / mktemp(3)</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="NSTemporaryDirectory / NSItemReplacementDirectory / mktemp(3),macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="NSTemporaryDirectory / NSItemReplacementDirectory / mktemp(3),macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>NSTemporaryDirectory / NSItemReplacementDirectory / mktemp(3)</span><span class=btRight><span title="Author · 作者" class=author>Mattt</span> <span title="Translator · 翻译" class=author>Croath Liu</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p>外存被用于写入可持续化保存的数据，但当数据生命周期很短时，用Objective-C操作临时文件的资料却很少（可能有，不过这些资料本身也是“临时”的）。</p><hr><p>临时文件的作用是在硬盘上简历buffer，既不会被原子化地转移到固定位置，也不会被某种合理的方式处理和销毁。需要找到文件系统上适当的位置、生成一个唯一的名字、再用完之后移动或删除文件的构思，才能去建立临时文件。</p><h2 id=寻找依赖目录>寻找依赖目录</h2><p>建立临时文件（或目录）的第一步就是找到适当的不碍事的地方去写这些文件，而且这个地方也不会被Time Machine或iCloud之类的东西同步。</p><p>实际上，在Unix系统中， <code>/tmp</code> 目录是最佳选择了。但现如今的iOS和Max OS X应用都有了自己的沙箱容器，所以最好还是不要用hard-code的路径了。</p><p><code>NSTemporaryDirectory</code> 是Foundation框架中的函数，这个函数会返回一个中相关系统上为写入临时文件而设计的目录。</p><h3 id=一场徒劳>一场徒劳</h3><p>近些年Apple把文件系统从那些调用 <code>NSString</code> 的地址的API中解放出来了，开发者改为用 <code>NSURL</code> 以及其上的API操作 <code>NSFileManager</code> 等类去解决这些问题。但这个解放并不是完全顺利的。</p><p>先看一看 <code>NSTemporaryDirectory</code> 的文档：</p><blockquote><p>请查看 <code>NSFileManager</code> 的 <code>URLForDirectory:inDomain:appropriateForURL:create:error:</code> 方法来作为寻找临时目录的首选方法。</p></blockquote><p>好吧，那看看<code>NSFileManager -URLForDirectory:inDomain:appropriateForURL:create:error:</code>方法里有什么：</p><blockquote><p>你可以用这个方法去建立临时文件目录去存储类似自动保存的文件等。依此方法建立临时目录时用 <code>NSItemReplacementDirectory</code> 作为 <code>directory</code> 参数、 <code>NSUserDomainMask</code> 作为 <code>domain </code>参数、用一个合法的父级目录作为 <code>url</code> 参数传入。建立完成后，这个方法会返回该目录的URL。</p></blockquote><p>这啥？读了好几遍我也没清楚怎么用。在邮件列表里找到<a href=http://lists.apple.com/archives/cocoa-dev/2012/Apr/msg00117.html>别人也</a>遇到了同样的<a href=http://lists.apple.com/archives/cocoa-dev/2012/Feb/msg00186.html>疑惑</a>。</p><p><em>实际上</em>，这个方法似乎是为配合 <code>-replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error:</code> 方法移动_现有_临时文件到硬盘上的固定位置而设计的，并不是我们要找的东西。</p><p>这些关于 <code>NSString</code> 文件系统的变革整合太多太多了，我们还是直接看一些有用的东西吧：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>[NSURL fileURLWithPath:NSTemporaryDirectory() isDirectory:YES];
</span></span></code></pre></div><h2 id=生成唯一的目录名或文件名>生成唯一的目录名或文件名</h2><p>找到了被（暂时）称作主目录的地方，下一步就是想办法去给临时文件命名。命名时除了文件名要唯一之外就没有什么好担心的事情了，这样做是为了不干预、也不被其他同名文件干扰。</p><p>生成唯一标示符的最佳办法是用 <code>NSProcessInfo</code> 的 <code>globallyUniqueString</code> 方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSString <span style=color:#f92672>*</span>identifier <span style=color:#f92672>=</span> [[NSProcessInfo processInfo] globallyUniqueString];
</span></span></code></pre></div><p>这个方法会返回这种格式的字符串： <code>5BD255F4-CA55-4B82-A555-0F4BC5CA2AD6-479-0000018E14D059CC</code></p><blockquote><p>也有其他人建议直接调用系统的 <code>mktemp(3)</code> 命令去防止重名冲突。但是用 <code>NSProcessInfo -globallyUniqueString</code> 方法显然不像能产生冲突的样子。</p></blockquote><p>还有个办法， <code>NSUUID</code> (<a href=https://nshipster.com/uuid-udid-unique-identifier>我们之前讨论过了</a>)也可以生成出可用的结果，但我不觉得你会做出_如此疯狂_的事情来。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>[[NSUUID UUID] UUIDString]
</span></span></code></pre></div><p>这个方法会返回这种格式的字符串： <code>22361D15-E17B-4C48-AEA6-C73BBEA17011</code></p><h2 id=建立临时文件地址>建立临时文件地址</h2><p>用上述方法可以生成唯一标示符了，于是就能生成唯一名字的临时文件地址了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSString <span style=color:#f92672>*</span>fileName <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;%@_%@&#34;</span>, [[NSProcessInfo processInfo] globallyUniqueString], <span style=color:#e6db74>@&#34;file.txt&#34;</span>];
</span></span><span style=display:flex><span>NSURL <span style=color:#f92672>*</span>fileURL <span style=color:#f92672>=</span> [NSURL fileURLWithPath:[NSTemporaryDirectory() stringByAppendingPathComponent:fileName]];
</span></span></code></pre></div><h2 id=建立临时目录>建立临时目录</h2><p>当一个程序需要生成很多临时文件时，建立子目录是一个好办法，可以帮助你简单快速地删除文件。</p><p>建立临时目录也是同样的方法调用 <code>NSFileManager -createDirectoryAtURL:withIntermediateDirectories:attributes:error:</code> ：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSURL <span style=color:#f92672>*</span>directoryURL <span style=color:#f92672>=</span> [NSURL fileURLWithPath:[NSTemporaryDirectory() stringByAppendingPathComponent:[[NSProcessInfo processInfo] globallyUniqueString]] isDirectory:YES];
</span></span><span style=display:flex><span>[[NSFileManager defaultManager] createDirectoryAtURL:directoryURL withIntermediateDirectories:YES attributes:nil error:<span style=color:#f92672>&amp;</span>error];
</span></span></code></pre></div><p>该目录的临时文件的地址要用 <code>URLByAppendingPathComponent:</code> 方法接上文件名：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSURL <span style=color:#f92672>*</span>fileURL <span style=color:#f92672>=</span> [directoryURL URLByAppendingPathComponent:fileName];
</span></span></code></pre></div><h2 id=向临时文件中写入内容>向临时文件中写入内容</h2><p>除非向文件中写入了内容或更新文件的时间戳，否则文件不会被建立。</p><h3 id=nsdata--writetourloptionserror>NSData -writeToURL:options:error</h3><p>Foundation库中有很多向硬盘写数据的方法，最直接的方法应该就是 <code>NSData -writeToURL:options:error</code> 了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSData <span style=color:#f92672>*</span>data <span style=color:#f92672>=</span> ...;
</span></span><span style=display:flex><span>NSError <span style=color:#f92672>*</span>error <span style=color:#f92672>=</span> nil;
</span></span><span style=display:flex><span>[data writeToURL:fileURL options:NSDataWritingAtomic error:<span style=color:#f92672>&amp;</span>error];
</span></span></code></pre></div><h3 id=nsoutputstream>NSOutputStream</h3><p>更高级的API中比较常见的就是直接向数据流传入一个 <code>NSOutputStream</code> 实例。同样的，通过建立输出流来向临时文件地址写入和其他写入方法没什么两样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSOutputStream <span style=color:#f92672>*</span>outputStream <span style=color:#f92672>=</span> [NSOutputStream outputStreamToFileAtPath:[fileURL absoluteString] append:NO];
</span></span></code></pre></div><h3 id=清除>清除</h3><p>最后一步就是让临时文件真正达到它_临时_的意义：清除。</p><p>虽然临时文件系统设计上没有说明临时文件在被系统自动删除前可以存在多久（至少最近没听到有人说过），但是你自己去管理好它是个很好的习惯。</p><p>用 <code>NSFileManager -removeItemAtURL:</code> 方法去删除临时文件或目录：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSError <span style=color:#f92672>*</span>error <span style=color:#f92672>=</span> nil;
</span></span><span style=display:flex><span>[[NSFileManager defaultManager] removeItemAtURL:fileURL error:<span style=color:#f92672>&amp;</span>error];
</span></span></code></pre></div><hr><p>“一切都会过去的！”这句谚语的意思就是所有的一切都是临时性的。在应用生命周期的上下文里，一些东西比其他的令具有临时性，所以我们应该为它们找到一个合理合适的地方去存放、保证唯一性、用过后不留痕迹。</p><p>或许我们可以从这个小小的应用生命周期中，学到一些关于我们短暂而灿烂的生命的意义。</p><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2014-03-03 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mattt 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Cocoa target=_blank>Cocoa</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>