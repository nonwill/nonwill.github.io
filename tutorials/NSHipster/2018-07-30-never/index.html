<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>Never</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="Never,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="Never,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>Never</span><span class=btRight><span title="Author · 作者" class=author>Mattt</span> <span title="Translator · 翻译" class=author>Xiang Wang</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p>“Never”是一个约定，表示一件事在过去或未来的任何时段都不会发生。它是时间轴上的一种逻辑上的不可能，在任何方向延展开去都没有可能。这就是为什么在代码中看到 <a href="https://github.com/search?q=%22this+will+never+happen%22&type=Code">这样的注释</a> 会特别让人不安。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// this will never happen</span>
</span></span></code></pre></div><p>所有编译器的教科书都会告诉你，这样一句注释不能也不会对编译出的代码产生任何影响。<a href=https://en.wikipedia.org/wiki/Murphy%27s_law>墨菲定理</a> 告诉你并非如此，注释以下的代码一定会被触发。</p><p>那 Swift 是如何在这种无法预测的、混乱的开发过程中保证安全呢？答案难以置信：“<strong>什么都不做</strong>”，以及“<strong>崩溃</strong>”。</p><hr><p>使用 <code>Never</code> 替换 <code>@noreturn</code> 修饰符，是由 <a href=https://github.com/jckarter>Joe Groff</a> 在 <a href=https://github.com/apple/swift-evolution/blob/master/proposals/0102-noreturn-bottom-type.md>SE-0102: “Remove @noreturn attribute and introduce an empty Never type”</a> 中提出的。</p><p>在 Swift 3 之前，那些要中断执行的函数，比如 <code>fatalError(_:file:line:)</code>，<code>abort()</code> 和 <code>exit(_:)</code>，需要使用 <code>@noreturn</code> 修饰符来声明，这会告诉编译器，执行完成之后不用返回到调用方。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// Swift &lt; 3.0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@noreturn</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fatalError</span>(<span style=color:#66d9ef>_</span> message: () -&gt; String = String(),
</span></span><span style=display:flex><span>                               file: StaticString = <span style=color:#66d9ef>#file</span>,
</span></span><span style=display:flex><span>                               line: UInt = <span style=color:#66d9ef>#line</span>)
</span></span></code></pre></div><p>从 Swift 3 开始，<code>fatalError</code> 和它的相关函数都被声明为返回 <code>Never</code> 类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// Swift &gt;= 3.0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fatalError</span>(<span style=color:#66d9ef>_</span> message: <span style=color:#66d9ef>@autoclosure</span> () -&gt; String = String(),
</span></span><span style=display:flex><span>                     file: StaticString = <span style=color:#66d9ef>#file</span>,
</span></span><span style=display:flex><span>                     line: UInt = <span style=color:#66d9ef>#line</span>) -&gt; Never
</span></span></code></pre></div><p>作为一个注释的替代品，它肯定是很复杂的，对吗？NO！事实上，恰恰相反，<code>Never</code> 可以说是整个 Swift 标准库中最简单的一个类型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Never</span> {}
</span></span></code></pre></div><h2 id=无实例类型uninhabited-types>无实例类型（Uninhabited Types）</h2><p><code>Never</code> 是一个 <em>无实例</em>（<em>Uninhabited</em>）类型，也就是说它没有任何值。或者换句话说，无实例类型是无法被构建的。</p><p>在 Swift 中，没有定义任何 <code>case</code> 的枚举是最常见的一种无实例类型。跟结构体和类不同，枚举没有初始化方法。跟协议也不同，枚举是一个具体的类型，可以包含属性、方法、泛型约束和嵌套类型。正因如此，Swift 标准库广泛使用无实例的枚举类型来做诸如 <a href=https://github.com/apple/swift/blob/a4230ab2ad37e37edc9ed86cd1510b7c016a769d/stdlib/public/core/Unicode.swift#L918>定义命名空间</a> 以及 <a href=https://github.com/apple/swift/blob/a6952decab6f918a9df3c6fa342153a9f9204f8e/stdlib/public/core/MemoryLayout.swift#L43>标识类型的含义</a> 之类的事情。</p><p>但 <code>Never</code> 并不这样。它没有什么花哨的东西，它的特别之处就在于，它就是它自己（或者说，它什么都不是）。</p><p>试想一个返回值为无实例类型的函数：因为无实例类型没有任何值，所以这个函数无法正常的返回。（它要如何生成这个返回值呢？）所以，这个函数要么停止运行，要么无休止的一直运行下去。</p><h2 id=消除泛型中的不可能状态>消除泛型中的不可能状态</h2><p>从理论角度上说，<code>Never</code> 确实很有意思，但它在实际应用中又能帮我们做什么呢？</p><p>做不了什么，至少在 <a href=https://github.com/apple/swift-evolution/blob/master/proposals/0215-conform-never-to-hashable-and-equatable.md#conform-never-to-equatable-and-hashable>SE-0215: Conform Never to Equatable and Hashable</a> 推出以前，做不了什么。</p><p><a href=https://github.com/mdiep>Matt Diephouse</a> 在提案中解释了为什么让这个令人费解的类型去遵守 <code>Equatable</code> 和其他协议：</p><blockquote><p><code>Never</code> 在表示不可能执行的代码方面非常有用。大部分人熟悉它，是因为它是 <code>fatalError</code> 等方法的返回值，但 <code>Never</code> 在泛型方面也非常有用。比如说，一个 <code>Result</code> 类型可以使用 <code>Never</code> 作为它的 <code>Value</code>，表示某种东西一直是错误的，或者使用 <code>Never</code> 作为它的 <code>Error</code>，表示某种东西一直不是错误的。</p></blockquote><p>Swift 没有标准的 <code>Result</code> 类型，大部分情况下它们是这个样子的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Result</span>&lt;Value, Error: Swift.Error&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> success(Value)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> failure(Error)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Result</code> 类型被用来封装异步操作生成的返回值和异常（同步操作可以使用 <code>throw</code> 来返回异常）。</p><p>比如说，一个发送异步 HTTP 请求的函数可能使用 <code>Result</code> 类型来存储响应或错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#66d9ef>_</span> request: Request, completion: (Result&lt;Response, Error&gt;) -&gt; Void) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>调用这个方法后，你可以使用 <code>switch</code> 来分别处理它的 <code>.success</code> 和 <code>.failure</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>fetch(request) { result <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> result {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> .success(<span style=color:#66d9ef>let</span> value):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;Success: </span><span style=color:#e6db74>\(</span>value<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> .failure(<span style=color:#66d9ef>let</span> error):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;Failure: </span><span style=color:#e6db74>\(</span>error<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在假设有一个函数会在它的 <code>completion</code> 中永远返回成功结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>alwaysSucceeds</span>(<span style=color:#66d9ef>_</span> completion: (Result&lt;String, Never&gt;) -&gt; Void) {
</span></span><span style=display:flex><span>    completion(.success(<span style=color:#e6db74>&#34;yes!&#34;</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>将 <code>Result</code> 的 <code>Error</code> 类型指定为 <code>Never</code> 后，我们可以使用类型检测体系来表明失败是永远不可能发生的。这样做的好处在于，你不需要处理 <code>.failure</code>，Swift 可以推断出这个 <code>switch</code> 语句已经处理了所有情况。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>alwaysSucceeds { (result) <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> result {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> .success(<span style=color:#66d9ef>let</span> string):
</span></span><span style=display:flex><span>        print(string)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>下面这个例子是让 <code>Never</code> 遵循 <code>Comparable</code> 协议，这段代码把 <code>Never</code> 用到了极致：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Never</span>: Comparable {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>func</span> <span style=color:#f92672>&lt;</span> (lhs: Never, rhs: Never) -&gt; Bool {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (lhs, rhs) {}
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因为 <code>Never</code> 是一个无实例类型，所以它没有任何可能的值。所以当我们使用 <code>switch</code> 遍历它的 <code>lhs</code> 和 <code>rhs</code> 时，Swift 可以确定所有的可能性都遍历了。既然所有的可能性 — 实际上这里不存在任何值 — 都返回了 <code>Bool</code>，那么这个方法就可以正常编译。</p><p><em>工整！</em></p><h2 id=使用-never-作为兜底类型>使用 <code>Never</code> 作为兜底类型</h2><p>实际上，关于 <code>Never</code> 的 Swift Evolution 提案中已经暗示了这个类型在未来可能有更多用处：</p><blockquote><p>一个无实例类型可以作为其他任意类型的子类型 — 如果某个表达式根本不可能产生任何结果，那么我们就不需要关心这个表达式的类型到底是什么。如果编译器支持这一特性，就可以实现很多有用的功能……</p></blockquote><h3 id=解包或者死亡>解包或者死亡</h3><p>强制解包操作（<code>!</code>）是 Swift 中最具争议的部分之一。（在代码中使用这个操作符）往好了说，是有意为之（在异常时故意让程序崩溃）；往坏了说，可能表示使用者没有认真思考。在缺乏其他信息的情况下，很难看出这两者的区别。</p><p>比如，下面的代码假定数组一定不为空，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> array: [Int]
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> firstIem = array.first!
</span></span></code></pre></div><p>为了避免强制解包，你可以使用带条件赋值的 <code>guard</code> 语句：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> array: [Int]
</span></span><span style=display:flex><span><span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> firstItem = array.first <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    fatalError(<span style=color:#e6db74>&#34;array cannot be empty&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>未来，如果 <code>Never</code> 成为兜底类型，它就可以用在 <code>nil-coalescing operator</code> 表达式的右边。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// 未来的 Swift 写法? 🔮</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> firstItem = array.first ?? fatalError(<span style=color:#e6db74>&#34;array cannot be empty&#34;</span>)
</span></span></code></pre></div><p>如果你想现在就使用这种模式，可以手动重载 <code>??</code> 运算符（但是……）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> ?? &lt;T&gt;(lhs: T?, rhs: <span style=color:#66d9ef>@autoclosure</span> () -&gt; Never) -&gt; T {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> lhs {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>let</span> value?:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> value
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>nil</span>:
</span></span><span style=display:flex><span>        rhs()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>在拒绝 <a href=https://github.com/apple/swift-evolution/blob/master/proposals/0217-bangbang.md#on-forced-unwraps>SE-0217: Introducing the !! “Unwrap or Die” operator to the Swift Standard Library</a> 的<a href=https://forums.swift.org/t/se-0217-the-unwrap-or-die-operator/14107/222>原因说明</a>中, <a href=https://github.com/jckarter>Joe Groff</a> 提到，“我们发现重载 [?? for Never] 会对类型检测的性能产生难以接受的影响”。所以，不建议你在自己的代码中添加上面的代码。</p></blockquote><h3 id=表达式风格的-throw>表达式风格的 Throw</h3><p>类似的，如果 <code>throw</code> 可以从语句变成一个返回 <code>Never</code>的表达式，你就可以在 <code>??</code> 右边使用 <code>throw</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// 未来的 Swift 写法? 🔮</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> firstItem = array.first ?? <span style=color:#66d9ef>throw</span> Error.empty
</span></span></code></pre></div><h3 id=带类型的-throw>带类型的 Throw</h3><p>继续研究下去：如果函数声明的 <code>throw</code> 关键字支持类型约束，那么 <code>Never</code> 可以用来表明某个函数绝对不会抛出异常（类似于在上面的 <code>Result</code> 例子）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// 未来的 Swift 写法? 🔮</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>neverThrows</span>() <span style=color:#66d9ef>throws</span>&lt;Never&gt; {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>neverThrows() <span style=color:#75715e>// 无需使用 `try` ，因为编译器保证它一定成功（可能）</span>
</span></span></code></pre></div><hr><p>声称某个事情永远不可能发生，就像是向整个宇宙发出邀请，来证明它是错的一样。情态逻辑（modal logic）或者信念逻辑（doxastic logic）允许保面子式的妥协（“<em>它当时是对的，至少我是这么认为的！</em>”），但时态逻辑（temporal logic）似乎将这个约定提到了更高的一个标准。</p><p>幸运的是，得益于最不像类型的 <code>Never</code>，Swift 到达了这个高标准。</p><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2018-07-30 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mattt 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Swift target=_blank>Swift</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>