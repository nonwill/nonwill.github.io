<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>NSCalendar Additions</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="NSCalendar Additions,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="NSCalendar Additions,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>NSCalendar Additions</span><span class=btRight><span title="Author · 作者" class=author>Nate Cook</span> <span title="Translator · 翻译" class=author>GWesley</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p><em>日期.</em> 一个很普通的时间和它的实现间往往有着巨大的差异，里面隐藏的多方面的复杂性远超其它数据类型。其中包括亚秒级的精度，重叠单元，不同地理位置的时区边界，语言和语法上的本地化差异，以及为了夏令时的转换和闰年调整，而在标准时间中添加删除整块的时间等等，里面有太多的东西需要进行处理。</p><p>在开始进行任何重度日期相关的任务前，我们有必要深入了解一下我们手中已有的工具。相比写上上千个版本的 <code>dateIsTomorrow</code>，我觉得更好的办法是使用 <code>Foundation</code> 方法。你有在用 <code>NSDateComponents</code> 吗？你有指定正确的日历单元吗？你的代码在 2100 年 2 月 28 号还能正常工作么？</p><p>但事实上：大家一直都在使用那些已经非常熟悉了的 APIs 。除非你跑去考察版本说明和 API 变动表，不然你肯定不会知道最近发布的几个 OS X 版本里，<code>NSCalendar</code> 已经添加了一系列功能十分强大的方法去操作计算日期，最近的一次发布让我们可以在 iOS 中使用这些方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> calendar = NSCalendar.currentCalendar()
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSCalendar <span style=color:#f92672>*</span>calendar <span style=color:#f92672>=</span> [NSCalendar currentCalendar];
</span></span></code></pre></div><p>从全新的日期组件存取与日期比较方法，到强大的日期插值与枚举方法，有太多的东西被我们忽视了。接下来让我们抽点时间来了解一下吧。</p><h2 id=便利的日期组件存取>便利的日期组件存取</h2><p>哇, <code>NSDateComponents</code> 真是既实用又灵活，但当我只是想知道间隔的小时数时，它用起来感觉又太麻烦了。不要慌， <code>NSCalendar</code> 来救你了！</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> hour = calendar.component(.CalendarUnitHour, fromDate: NSDate())
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSInteger hour <span style=color:#f92672>=</span> [calendar component:NSCalendarUnitHour fromDate:[NSDate date]];
</span></span></code></pre></div><p>这样就好多了。<code>NSCalendar</code>，你还有哪些本事？</p><blockquote><ul><li><code>getEra(_:year:month:day:fromDate:)</code>：根据传入的日期引用返回纪元，年，月，日。不需要的参数可以传入 <code>nil</code>/<code>NULL</code>。</li><li><code>getEra(_:yearForWeekOfYear:weekOfYear:weekday:fromDate:)</code>: 根据传入的日期引用返回纪元，年，当年第几周，星期几。不需要的参数可以传入 <code>nil</code>/<code>NULL</code>。</li><li><code>getHour(_:minute:second:nanosecond:fromDate:)</code>: 根据传入的日期引用返回时间信息，然后 <code>nil</code>/<code>NULL</code> 巴拉巴拉, 你懂的。</li></ul></blockquote><p><code>NSDateComponents</code>，刚才我是逗你玩呢，我收回前面吐槽你的话。下面还有不少属于你的方法：</p><blockquote><ul><li><code>componentsInTimeZone(_:fromDate:)</code>: 根据传入的的日期和时区返回一个 <code>NSDateComponents</code> 实例。</li><li><code>components(_:fromDateComponents:toDateComponents:options:)</code>: 返回两个 <code>NSDateComponents</code> 实例间的差异。如果有未赋值的组件，该方法会使用默认值，所以我们传入的实例至少得设置了年属性。options参数暂时没有用，传 <code>nil</code>/<code>0</code> 就行。</li></ul></blockquote><h2 id=日期比较>日期比较</h2><p>虽然直接比较 <code>NSDate</code> 是件挺简单的事，但一些更有意义的比较可能变得惊人的复杂。两个 <code>NSDate</code> 实例是同一天？同一小时？亦或是同一周？</p><p>现在没必要发愁了，<code>NSCalendar</code> 提供了大量的比较方法：</p><blockquote><ul><li><code>isDateInToday(_:)</code>: 如果传入的日期是当天返回 <code>true</code> 。</li><li><code>isDateInTomorrow(_:)</code>: 如果传入的日期是明天返回 <code>true</code> 。</li><li><code>isDateInYesterday(_:)</code>: 如果传入的日期是昨天返回 <code>true</code> 。</li><li><code>isDateInWeekend(_:)</code>: 如果传入的日期是周末返回 <code>true</code> 。</li><li><code>isDate(_:inSameDayAsDate:)</code>: 如果两个 <code>NSDate</code> 实例在同一天返回 <code>true</code> - 没必要再去获取日期部件进行比较了。</li><li><code>isDate(_:equalToDate:toUnitGranularity:)</code>: 如果传入的日期在同一指定单位内返回 <code>true</code> 。这意味着，两个在同一周的日期实例调用 <code>calendar.isDate(tuesday, equalToDate: thursday, toUnitGranularity: .CalendarUnitWeekOfYear)</code> 方法时会返回 <code>true</code> ，就算他们不在同一个月也是如此。</li><li><code>compareDate(_:toDate:toUnitGranularity:)</code>: 返回一个 <code>NSComparisonResult</code>，当做和任何指定区间内的日期相等。</li><li><code>date(_:matchesComponents:)</code>: 如果日期匹配指定的部件返回 <code>true</code> 。</li></ul></blockquote><h2 id=日期插值>日期插值</h2><p>接下来讲一些根据起始点寻找下一个日期的方法。你可以基于一个 <code>NSDateComponents</code> 实例，一个指定的日期组件，或者特定的时分秒，去找到下一个（或上一个）日期。所有这些方法都需要一个 <code>NSCalendarOptions</code> 位参数去提供更加精细的控制，特别是一开始我们没能找到准确的匹配的时候，它可以帮我们确定如何选定下一个日期。</p><h3 id=nscalendaroptions><code>NSCalendarOptions</code></h3><p>最简单的 <code>NSCalendarOptions</code> 选项是 <code>.SearchBackwards</code>，使用它我们可以在所有方法中进行反向搜索。反向搜索和正向搜索得到的结果是类似的。举个例子，反向搜索 11 之前的一个 <code>小时</code> 会给你返回 11：00， 而不是 11：59， 虽然在反向搜索中 11：59 严格意义上来讲是比 11：00 “早”。确实，反向搜索咋一看是符合直觉的，但想多了很可能会把你绕进去。既然 <code>.SearchBackwards</code> 是已经是最简单的选项，你大概能才猜到后面都是些什么鬼。</p><p>接下来的 <code>NSCalendarOptions</code> 选项能够帮助我们处理那些 “消失” 的时间。举个最直观的例子来说，当你进行一个短时窗搜索时碰到夏令时调整，时间提前了一个小时。或者搜索时遇到类似 2 月 或者 4 月 31 号，它都能帮我们跳过这些缺失的时间。</p><p>当遇到缺失的时间时，如果我们设置了 <code>NSCalendarOptions.MatchStrictly</code>，相关方法会根据传入的组件寻找一个 <code>精确</code> 的匹配。如果没有设置的话，那么必须提供 <code>.MatchNextTime</code>, <code>.MatchNextTimePreservingSmallerUnits</code>, 和 <code>.MatchPreviousTimePreservingSmallerUnits</code> 中的任一项。这些选项决定了如何处理我们请求时遇到的时间缺失问题。</p><p>这种情况，往往一例胜千言：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// 2015 年情人节，早上 9 点</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> valentines = cal.dateWithEra(<span style=color:#ae81ff>1</span>, year: <span style=color:#ae81ff>2015</span>, month: <span style=color:#ae81ff>2</span>, day: <span style=color:#ae81ff>14</span>, hour: <span style=color:#ae81ff>9</span>, minute: <span style=color:#ae81ff>0</span>, second: <span style=color:#ae81ff>0</span>, nanosecond: <span style=color:#ae81ff>0</span>)<span style=color:#f92672>!</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 为了找到月的最后一天， 我设置一个日期组件然后把 `day` 设成 31：</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> components = NSDateComponents()
</span></span><span style=display:flex><span>components.day = <span style=color:#ae81ff>31</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSDate <span style=color:#f92672>*</span>valentines <span style=color:#f92672>=</span> [calendar dateWithEra:<span style=color:#ae81ff>1</span> year:<span style=color:#ae81ff>2015</span> month:<span style=color:#ae81ff>2</span> day:<span style=color:#ae81ff>14</span> hour:<span style=color:#ae81ff>9</span> minute:<span style=color:#ae81ff>0</span> second:<span style=color:#ae81ff>0</span> nanosecond:<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>NSDateComponents <span style=color:#f92672>*</span>components <span style=color:#f92672>=</span> [[NSDateComponents alloc] init];
</span></span><span style=display:flex><span>components.day <span style=color:#f92672>=</span> <span style=color:#ae81ff>31</span>;
</span></span></code></pre></div><p>使用精确匹配会在三月找到下个 <code>31</code> 号，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>calendar.nextDateAfterDate(valentines, matchingComponents: components, options: .MatchStrictly)
</span></span><span style=display:flex><span><span style=color:#75715e>// Mar 31, 2015, 12:00 AM</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSDate <span style=color:#f92672>*</span>date <span style=color:#f92672>=</span> [calendar nextDateAfterDate:valentines matchingComponents:components options:NSCalendarMatchStrictly];
</span></span><span style=display:flex><span><span style=color:#75715e>// Mar 31, 2015, 12:00 AM
</span></span></span></code></pre></div><p>不使用精确匹配的话，<code>nextDateAfterDate</code> 方法会在找到匹配的指定天数前就在二月底停了下来，然后在下个月继续寻找。 可见，你所提供的选项决定了最终返回的具体日期。举例来说，使用 <code>.MatchNextTime</code> 选项找到下一个合适的日子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>calendar.nextDateAfterDate(valentines, matchingComponents: components, options: .MatchNextTime)
</span></span><span style=display:flex><span><span style=color:#75715e>// Mar 1, 2015, 12:00 AM</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>date <span style=color:#f92672>=</span> [calendar nextDateAfterDate:valentines matchingComponents:components options:NSCalendarMatchNextTime];
</span></span><span style=display:flex><span><span style=color:#75715e>// Mar 1, 2015, 12:00 AM
</span></span></span></code></pre></div><p>类似的，当使用 <code>.MatchNextTimePreservingSmallerUnits</code> 选项时会找到下一天，但是所有比指定单元 <code>NSCalendarUnitDay</code> 要小的单元会被保留下来：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>calendar.nextDateAfterDate(valentines, matchingComponents: components, options: .MatchNextTimePreservingSmallerUnits)
</span></span><span style=display:flex><span><span style=color:#75715e>// Mar 1, 2015, 9:00 AM</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>date <span style=color:#f92672>=</span> [calendar nextDateAfterDate:valentines matchingComponents:components options:NSCalendarMatchNextTimePreservingSmallerUnits];
</span></span><span style=display:flex><span><span style=color:#75715e>// Mar 1, 2015, 9:00 AM
</span></span></span></code></pre></div><p>最后， 使用 <code>.MatchPreviousTimePreservingSmallerUnits</code> 选项会在 <em>另一个</em> 方向上解决缺失的时间问题， 和前面一样，保留较小的单元，然后找到匹配的前一天：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>calendar.nextDateAfterDate(valentines, matchingComponents: components, options: .MatchPreviousTimePreservingSmallerUnits)
</span></span><span style=display:flex><span><span style=color:#75715e>// Feb 28, 2015, 9:00 AM</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>date <span style=color:#f92672>=</span> [calendar nextDateAfterDate:valentines matchingComponents:components options:NSCalendarMatchPreviousTimePreservingSmallerUnits];
</span></span><span style=display:flex><span><span style=color:#75715e>// Feb 28, 2015, 9:00 AM
</span></span></span></code></pre></div><p>除了这里的 <code>NDateComponents</code> 外，还值得注意的是 <code>nextDateAfterDate</code> 方法有两种变化：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// 匹配指定的日历单元</span>
</span></span><span style=display:flex><span>cal.nextDateAfterDate(valentines, matchingUnit: .CalendarUnitDay, value: <span style=color:#ae81ff>31</span>, options: .MatchStrictly)
</span></span><span style=display:flex><span><span style=color:#75715e>// March 31, 2015, 12:00 AM</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 匹配时，分，秒</span>
</span></span><span style=display:flex><span>cal.nextDateAfterDate(valentines, matchingHour: <span style=color:#ae81ff>15</span>, minute: <span style=color:#ae81ff>30</span>, second: <span style=color:#ae81ff>0</span>, options: .MatchNextTime)
</span></span><span style=display:flex><span><span style=color:#75715e>// Feb 14, 2015, 3:30 PM</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#75715e>// 匹配指定的日历单元
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>date <span style=color:#f92672>=</span> [calendar nextDateAfterDate:valentines matchingUnit:NSCalendarUnitDay value:<span style=color:#ae81ff>31</span> options:NSCalendarMatchStrictly];
</span></span><span style=display:flex><span><span style=color:#75715e>// March 31, 2015, 12:00 AM
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span><span style=color:#75715e>// 匹配时，分，秒
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>date <span style=color:#f92672>=</span> [calendar nextDateAfterDate:valentines matchingHour:<span style=color:#ae81ff>15</span> minute:<span style=color:#ae81ff>30</span> second:<span style=color:#ae81ff>0</span> options:NSCalendarMatchNextTime];
</span></span><span style=display:flex><span><span style=color:#75715e>// Feb 14, 2015, 3:30 PM
</span></span></span></code></pre></div><h3 id=枚举插值日期>枚举插值日期</h3><p><code>NSCalendar</code> 提供了一个API去枚举日期， 所以大家没有必要反复的调用 <code>nextDateAfterDate</code> 方法。<code>enumerateDatesStartingAfterDate(_:matchingComponents:options:usingBlock:)</code> 方法根据提供的日期组件和选项，依次获取匹配的日期。可以将 <code>stop</code> 属性设为 <code>true</code> 去停止枚举。</p><p>来试试这个 <code>NSCalendarOptions</code> 的新方法吧，下面展示了一种获取随后50个闰年的方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> leapYearComponents = NSDateComponents()
</span></span><span style=display:flex><span>leapYearComponents.month = <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>leapYearComponents.day = <span style=color:#ae81ff>29</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> dateCount = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>cal.enumerateDatesStartingAfterDate(NSDate(), matchingComponents: leapYearComponents, options: .MatchStrictly <span style=color:#f92672>|</span> .SearchBackwards) 
</span></span><span style=display:flex><span>{ (date: NSDate!, exactMatch: Bool, stop: UnsafeMutablePointer&lt;ObjCBool&gt;) <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    println(date)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>++</span>dateCount == <span style=color:#ae81ff>50</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// .memory 用来获取一个 UnsafeMutablePointer 属性的值</span>
</span></span><span style=display:flex><span>        stop.memory = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 2012-02-29 05:00:00 +0000</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2008-02-29 05:00:00 +0000</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2004-02-29 05:00:00 +0000</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2000-02-29 05:00:00 +0000</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSDateComponents <span style=color:#f92672>*</span>leapYearComponents <span style=color:#f92672>=</span> [[NSDateComponents alloc] init];
</span></span><span style=display:flex><span>leapYearComponents.month <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>leapYearComponents.day <span style=color:#f92672>=</span> <span style=color:#ae81ff>29</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>__block</span> <span style=color:#66d9ef>int</span> dateCount <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>[calendar enumerateDatesStartingAfterDate:[NSDate date]
</span></span><span style=display:flex><span>                      matchingComponents:leapYearComponents
</span></span><span style=display:flex><span>                                 options:NSCalendarMatchStrictly <span style=color:#f92672>|</span> NSCalendarSearchBackwards
</span></span><span style=display:flex><span>                              usingBlock:<span style=color:#f92672>^</span>(NSDate <span style=color:#f92672>*</span>date, <span style=color:#66d9ef>BOOL</span> exactMatch, <span style=color:#66d9ef>BOOL</span> <span style=color:#f92672>*</span>stop) {
</span></span><span style=display:flex><span>    NSLog(<span style=color:#e6db74>@&#34;%@&#34;</span>, date);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>++</span>dateCount <span style=color:#f92672>==</span> <span style=color:#ae81ff>50</span>) {
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>stop <span style=color:#f92672>=</span> YES;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}];
</span></span><span style=display:flex><span><span style=color:#75715e>// 2012-02-29 05:00:00 +0000
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 2008-02-29 05:00:00 +0000
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 2004-02-29 05:00:00 +0000
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 2000-02-29 05:00:00 +0000
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span></code></pre></div><h3 id=处理周末>处理周末</h3><p>要想找周末的话，记住下面两个 <code>NSCalendar</code> 方法就行：</p><blockquote><ul><li><code>nextWeekendStartDate(_:interval:options:afterDate)</code>: 根据传入的前两个参数返回下个周末的开始时间个长度。如果当前的地区和日历未提供对周末属性的支持，该方法会返回 <code>false</code> 。唯一相关的属性是 <code>.SearchBackwards</code>。（例子在下面。）</li><li><code>rangeOfWeekendStartDate(_:interval:containingDate)</code>: 根据传入的前两个参数返回 <em>包含</em> 该日期的周末。如果传入的日期并不在周末或者当前的地区和日历未提供对周末属性的支持，该方法会返回 <code>false</code> 。</li></ul></blockquote><h2 id=本地化日期符号>本地化日期符号</h2><p>似乎所有这些新功能还不够丰富似的， <code>NSCalendar</code> 还提供了一整套的本地化日期符号，用来快速获取月份名称，星期名称等等。每组符号都列举在两个轴上：(1) 符号的长度 (2) 它是作为标准名称还是日期的一部分。</p><p>理解这两个属性对本地化来说十分的重要，有些语言，特别是斯拉夫语言，会依据不同的内容使用不同的名词格。举例来说，一个日期要使用某个 <code>standaloneMonthSymbols</code> 的变体作为头，而不是使用 <code>monthSymbols</code> 去格式化日期。</p><p>下面这张表包含了 <code>NSCalendar</code> 提供的所有符号，供大家阅览，请注意俄语列中独立符号的不同之处：</p><table><thead><tr><th> </th><th>en_US</th><th>ru_RU</th></tr></thead><tbody><tr><td><code>monthSymbols</code></td><td>January, February, March…</td><td>января, февраля, марта…</td></tr><tr><td><code>shortMonthSymbols</code></td><td>Jan, Feb, Mar…</td><td>янв., февр., марта…</td></tr><tr><td><code>veryShortMonthSymbols</code></td><td>J, F, M, A…</td><td>Я, Ф, М, А…</td></tr><tr><td><code>standaloneMonthSymbols</code></td><td>January, February, March…</td><td>Январь, Февраль, Март…</td></tr><tr><td><code>shortStandaloneMonthSymbols</code></td><td>Jan, Feb, Mar…</td><td>Янв., Февр., Март…</td></tr><tr><td><code>veryShortStandaloneMonthSymbols</code></td><td>J, F, M, A…</td><td>Я, Ф, М, А…</td></tr><tr><td><code>weekdaySymbols</code></td><td>Sunday, Monday, Tuesday, Wednesday…</td><td>воскресенье, понедельник, вторник, среда…</td></tr><tr><td><code>shortWeekdaySymbols</code></td><td>Sun, Mon, Tue, Wed…</td><td>вс, пн, вт, ср…</td></tr><tr><td><code>veryShortWeekdaySymbols</code></td><td>S, M, T, W…</td><td>вс, пн, вт, ср…</td></tr><tr><td><code>standaloneWeekdaySymbols</code></td><td>Sunday, Monday, Tuesday, Wednesday…</td><td>Воскресенье, Понедельник, Вторник, Среда…</td></tr><tr><td><code>shortStandaloneWeekdaySymbols</code></td><td>Sun, Mon, Tue, Wed…</td><td>Вс, Пн, Вт, Ср…</td></tr><tr><td><code>veryShortStandaloneWeekdaySymbols</code></td><td>S, M, T, W…</td><td>В, П, В, С…</td></tr><tr><td><code>AMSymbol</code></td><td>AM</td><td>AM</td></tr><tr><td><code>PMSymbol</code></td><td>PM</td><td>PM</td></tr><tr><td><code>quarterSymbols</code></td><td>1st quarter, 2nd quarter, 3rd quarter, 4th quarter</td><td>1-й квартал, 2-й квартал, 3-й квартал, 4-й квартал</td></tr><tr><td><code>shortQuarterSymbols</code></td><td>Q1, Q2, Q3, Q4</td><td>1-й кв., 2-й кв., 3-й кв., 4-й кв.</td></tr><tr><td><code>standaloneQuarterSymbols</code></td><td>1st quarter, 2nd quarter, 3rd quarter, 4th quarter</td><td>1-й квартал, 2-й квартал, 3-й квартал, 4-й квартал</td></tr><tr><td><code>shortStandaloneQuarterSymbols</code></td><td>Q1, Q2, Q3, Q4</td><td>1-й кв., 2-й кв., 3-й кв., 4-й кв.</td></tr><tr><td><code>eraSymbols</code></td><td>BC, AD</td><td>до н. э., н. э.</td></tr><tr><td><code>longEraSymbols</code></td><td>Before Christ, Anno Domini</td><td>до н.э., н.э.</td></tr></tbody></table><blockquote><p><em>注：</em> 这些符号在 <code>NSDateFormatter</code> 中也可以使用。</p></blockquote><h2 id=你的每周swift化>你的每周Swift化</h2><p>在 NSHipster 我们讨论 API 的时候会有一些 Swift 的版本，这渐渐变成了我们的特色。 甚至是在讨论这些全新的 <code>NSCalendar</code> API的时候，我们需要把前面的方法再打磨一下，将 <code>UnsafeMutablePointer</code> 参数替换为更符合语言习惯的元组返回值。</p><p>这里给大家介绍一个非常好用的 <code>NSCalendar</code> 扩展集（<a href=https://gist.github.com/natecook1000/43976a66fa04e3fdb3c7> 点 我 </a>），有了它我们使用访问日期组件和搜索周末方法时，可以不用把值传进又传出。比如，获取指定的日期组件就变得简单的多：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// built-in</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> hour = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> minute = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>calendar.getHour(&amp;hour, minute: &amp;minute, second: <span style=color:#66d9ef>nil</span>, nanosecond: <span style=color:#66d9ef>nil</span>, fromDate: NSDate())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Swift化</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> (hour, minute, <span style=color:#66d9ef>_</span>, <span style=color:#66d9ef>_</span>) = calendar.getTimeFromDate(NSDate())
</span></span></code></pre></div><p>获取下一个周末的日期范围：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// built-in</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> startDate: NSDate?
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> interval: NSTimeInterval = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> success = cal.nextWeekendStartDate(&amp;startDate, interval: &amp;interval, options: <span style=color:#66d9ef>nil</span>, afterDate: NSDate())
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> success, <span style=color:#66d9ef>let</span> startDate = startDate {
</span></span><span style=display:flex><span>    println(<span style=color:#e6db74>&#34;start: </span><span style=color:#e6db74>\(</span>startDate<span style=color:#e6db74>)</span><span style=color:#e6db74>, interval: </span><span style=color:#e6db74>\(</span>interval<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Swift化</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> nextWeekend = cal.nextWeekendAfterDate(NSDate()) {
</span></span><span style=display:flex><span>    println(<span style=color:#e6db74>&#34;start: </span><span style=color:#e6db74>\(</span>nextWeekend.startDate<span style=color:#e6db74>)</span><span style=color:#e6db74>, interval: </span><span style=color:#e6db74>\(</span>nextWeekend.interval<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><p>这下复杂的日历计算吓不到你们了。有了 <code>NSCalendar</code> 提供的这些新功能，你可以很快的解决你碰到的问题。</p><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2015-03-16 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Nate Cook 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Cocoa target=_blank>Cocoa</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>