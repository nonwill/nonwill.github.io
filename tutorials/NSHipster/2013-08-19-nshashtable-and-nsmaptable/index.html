<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>NSHashTable & NSMapTable</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="NSHashTable & NSMapTable,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="NSHashTable & NSMapTable,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>NSHashTable & NSMapTable</span><span class=btRight><span title="Author · 作者" class=author>Mattt</span> <span title="Translator · 翻译" class=author>Chester Liu</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p><code>NSSet</code> 和 <code>NSDictionary</code>，连同 <code>NSArray</code> 是 Foundation 框架中最常用的几个集合类型。和<a href=https://en.wikipedia.org/wiki/Java_collections_framework>其它标准库</a>不同的是，它们的实现细节<a href=http://ridiculousfish.com/blog/posts/array.html>没有</a>对开发者公开，使得开发者只能编写简单的代码，相信框架（在合理的程度上）是高效的。</p><p>然而，再好的抽象也有不好用的时候。当对他们底层的实现假设不符合预期的时候，开发者要么继续在抽象层次上进行探索，要么在可能的情况下，使用更加通用的解决方案。</p><p>对于 <code>NSSet</code> 和 <code>NSDictionary</code> 来说，不符合预期的部分通常在于它们存储对象时在内存中的表现。对于 <code>NSSet</code>，对象在存储时会被强引用，<code>NSDictionary</code> 中值的存储也是一样。对键来说，在 <code>NSDictionary</code> 中会被拷贝。如果开发者想存储弱引用的值，或者使用一个没有遵守 <code>&lt;NSCopying></code> 的对象作为键，他可以选择聪明的办法，使用 <a href=https://nshipster.cn/nsvalue/><code>NSValue +valueWithNonretainedObject</code></a>。或者，在 iOS 6（以及 OS X Leopard）上，他可以使用 <code>NSHashTable</code> 或 <code>NSMapTable</code>，分别对应着 <code>NSSet</code> 和 <code>NSDictionary</code>，是它们更加通用的版本。</p><p>废话不多说，对这两个 Foundation 框架中最不知名的集合类型，下面是你所需要知道的一切：</p><h2 id=nshashtable><code>NSHashTable</code></h2><p><code>NSHashTable</code> 是 <code>NSSet</code> 的通用版本，和 <code>NSSet</code> / <code>NSMutableSet</code> 不同的是，<code>NSHashTable</code> 具有下面这些特性：</p><ul><li><code>NSSet</code> / <code>NSMutableSet</code> 持有成员的强引用，通过 <code>hash</code> 和 <code>isEqual:</code> 方法来检测成员的散列值和相等性。</li><li><code>NSHashTable</code> 是可变的，没有不可变的对应版本。</li><li><code>NSHashTable</code> 可以持有成员的弱引用。</li><li><code>NSHashTable</code> 可以在加入成员时进行 <code>copy</code> 操作。</li><li><code>NSHashTable</code> 可以存储任意的指针，通过指针来进行相等性和散列检查。</li></ul><h3 id=用法>用法</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> hashTable = NSHashTable(options: .CopyIn)
</span></span><span style=display:flex><span>hashTable.addObject(<span style=color:#e6db74>&#34;foo&#34;</span>)
</span></span><span style=display:flex><span>hashTable.addObject(<span style=color:#e6db74>&#34;bar&#34;</span>)
</span></span><span style=display:flex><span>hashTable.addObject(<span style=color:#ae81ff>42</span>)
</span></span><span style=display:flex><span>hashTable.removeObject(<span style=color:#e6db74>&#34;bar&#34;</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;Members: </span><span style=color:#e6db74>\(</span>hashTable.allObjects<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSHashTable <span style=color:#f92672>*</span>hashTable <span style=color:#f92672>=</span> [NSHashTable hashTableWithOptions:NSPointerFunctionsCopyIn];
</span></span><span style=display:flex><span>[hashTable addObject:<span style=color:#e6db74>@&#34;foo&#34;</span>];
</span></span><span style=display:flex><span>[hashTable addObject:<span style=color:#e6db74>@&#34;bar&#34;</span>];
</span></span><span style=display:flex><span>[hashTable addObject:<span style=color:#ae81ff>@42</span>];
</span></span><span style=display:flex><span>[hashTable removeObject:<span style=color:#e6db74>@&#34;bar&#34;</span>];
</span></span><span style=display:flex><span>NSLog(<span style=color:#e6db74>@&#34;Members: %@&#34;</span>, [hashTable allObjects]);
</span></span></code></pre></div><p><code>NSHashTable</code> 对象在初始化时可以选择下面任意一个选项来产生不同的行为。在 <code>NSHashTable</code> 从具有垃圾回收机制的 OS X 环境被移植到 ARC 化的 iOS 环境的过程中，有一些选项枚举值被废弃了。其余的选项值对应着 <a href=https://developer.apple.com/library/ios/DOCUMENTATION/Cocoa/Reference/Foundation/Classes/NSPointerFunctions_Class/Introduction/Introduction.html>NSPointerFunctions</a> 的选项，这部分内容会在下周的 NSHipster 中进行讲解。（译者注：下面具体的内容来自官方文档，不再做翻译，NSMapTable 部分做相同处理）</p><blockquote><ul><li><code>NSHashTableStrongMemory</code>: Equal to <code>NSPointerFunctionsStrongMemory</code>. This is the default behavior, equivalent to <code>NSSet</code> member storage.</li><li><code>NSHashTableWeakMemory</code>: Equal to <code>NSPointerFunctionsWeakMemory</code>. Uses weak read and write barriers. Using <code>NSPointerFunctionsWeakMemory</code>, object references will turn to <code>NULL</code> on last release.</li><li><code>NSHashTableZeroingWeakMemory</code>: This option has been deprecated. Instead use the <code>NSHashTableWeakMemory</code> option.</li><li><code>NSHashTableCopyIn</code>: Use the memory acquire function to allocate and copy items on input (see <a href=https://developer.apple.com/library/ios/DOCUMENTATION/Cocoa/Reference/Foundation/Classes/NSPointerFunctions_Class/Introduction/Introduction.html#//apple_ref/occ/instp/NSPointerFunctions/acquireFunction><code>NSPointerFunction -acquireFunction</code></a>). Equal to <code>NSPointerFunctionsCopyIn</code>.</li><li><code>NSHashTableObjectPointerPersonality</code>: Use shifted pointer for the hash value and direct comparison to determine equality; use the description method for a description. Equal to <code>NSPointerFunctionsObjectPointerPersonality</code>.</li></ul></blockquote><h2 id=nsmaptable><code>NSMapTable</code></h2><p><code>NSMapTable</code> 是 <code>NSDictionary</code> 的通用版本。和 <code>NSDictionary</code> / <code>NSMutableDictionary</code> 不同的是，<code>NSMapTable</code> 具有下面这些特性：</p><ul><li><code>NSDictionary</code> / <code>NSMutableDictionary</code> 对键进行拷贝，对值持有强引用。</li><li><code>NSMapTable</code> 是可变的，没有不可变的对应版本。</li><li><code>NSMapTable</code> 可以持有键和值的弱引用，当键或者值当中的一个被释放时，整个这一项就会被移除掉。</li><li><code>NSMapTable</code> 可以在加入成员时进行 <code>copy</code> 操作。</li><li><code>NSMapTable</code> 可以存储任意的指针，通过指针来进行相等性和散列检查。</li></ul><blockquote><p><em>注意：</em> <code>NSMapTable</code> 专注于强引用和弱引用，意味着 Swift 中流行的值类型是不适用的，只能用于引用类型。</p></blockquote><h3 id=用法-1>用法</h3><p>下面的例子展示了如何使用 <code>NSMapTable</code> 来包含不可拷贝的键，以及存储键对应的 delegate 或其他值的弱引用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> delegate: AnyObject = ...
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> mapTable = NSMapTable(keyOptions: .StrongMemory, valueOptions: .WeakMemory)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mapTable.setObject(delegate, forKey: <span style=color:#e6db74>&#34;foo&#34;</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;Keys: </span><span style=color:#e6db74>\(</span>mapTable.keyEnumerator<span style=color:#e6db74>()</span>.allObjects<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>id</span> delegate <span style=color:#f92672>=</span> ...;
</span></span><span style=display:flex><span>NSMapTable <span style=color:#f92672>*</span>mapTable <span style=color:#f92672>=</span> [NSMapTable mapTableWithKeyOptions:NSMapTableStrongMemory
</span></span><span style=display:flex><span>                                             valueOptions:NSMapTableWeakMemory];
</span></span><span style=display:flex><span>[mapTable setObject:delegate forKey:<span style=color:#e6db74>@&#34;foo&#34;</span>];
</span></span><span style=display:flex><span>NSLog(<span style=color:#e6db74>@&#34;Keys: %@&#34;</span>, [[mapTable keyEnumerator] allObjects]);
</span></span></code></pre></div><p><code>NSMapTable</code> 对象在初始化时需要使用下面这些选项来指定键和值的具体行为：</p><blockquote><ul><li><code>NSMapTableStrongMemory</code>: Specifies a strong reference from the map table to its contents.</li><li><code>NSMapTableWeakMemory</code>: Uses weak read and write barriers appropriate for ARC or GC. Using <code>NSPointerFunctionsWeakMemory</code>, object references will turn to <code>NULL</code> on last release. Equal to <code>NSMapTableZeroingWeakMemory</code>.</li><li><code>NSHashTableZeroingWeakMemory</code>: This option has been superseded by the <code>NSMapTableWeakMemory</code> option.</li><li><code>NSMapTableCopyIn</code>: Use the memory acquire function to allocate and copy items on input (see acquireFunction (see <a href=https://developer.apple.com/library/ios/DOCUMENTATION/Cocoa/Reference/Foundation/Classes/NSPointerFunctions_Class/Introduction/Introduction.html#//apple_ref/occ/instp/NSPointerFunctions/acquireFunction><code>NSPointerFunction -acquireFunction</code></a>). Equal to NSPointerFunctionsCopyIn.</li><li><code>NSMapTableObjectPointerPersonality</code>: Use shifted pointer hash and direct equality, object description.
Equal to <code>NSPointerFunctionsObjectPointerPersonality</code>.</li></ul></blockquote><h3 id=使用下标>使用下标</h3><p><code>NSMapTable</code> 没有实现<a href=https://nshipster.cn/object-subscripting/>对象下标索引</a>，不过通过 category 来添加这个特性并不是很麻烦。<code>NSDictionary</code> 对于键要遵守 <code>NSCopying</code> 的要求，只适用于 <code>NSDictionary</code> 本身：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>NSMapTable</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>subscript</span>(key: AnyObject) -&gt; AnyObject? {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>get</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> objectForKey(key)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>set</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> newValue <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                setObject(newValue, forKey: key)
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                removeObjectForKey(key)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>@implementation</span> <span style=color:#a6e22e>NSMapTable</span> (NSHipsterSubscripting)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>objectForKeyedSubscript:</span>(<span style=color:#66d9ef>id</span>)key
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [self objectForKey:key];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>setObject:</span>(<span style=color:#66d9ef>id</span>)obj <span style=color:#a6e22e>forKeyedSubscript:</span>(<span style=color:#66d9ef>id</span>)key
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (obj <span style=color:#f92672>!=</span> nil) {
</span></span><span style=display:flex><span>        [self setObject:obj forKey:key];
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        [self removeObjectForKey:key];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@end</span>
</span></span></code></pre></div><hr><p>和往常一样，记住一点，编程并不是要做到多么聪明：永远先从最高的抽象层次去尝试解决问题。<code>NSSet</code> 和 <code>NSDictionary</code> 都是 <em>非常好</em> 的工具。在 99% 的情况下，它们毋庸置疑是正确的选择。如果你碰到的问题包含上面提到的具体的内存管理需求，那么 <code>NSHashTable</code> 和 <code>NSMapTable</code> 值得你一看。</p><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2013-08-19 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mattt 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Cocoa target=_blank>Cocoa</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>