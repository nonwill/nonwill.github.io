<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>numericCast(_:)</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="numericCast(_:),macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="numericCast(_:),macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>numericCast(_:)</span><span class=btRight><span title="Author · 作者" class=author>Mattt</span> <span title="Translator · 翻译" class=author>Bei Li</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p>每个人都曾将编程比喻成其他事物。</p><p>类比成木工、编织或者园艺。又或者可能类比成解决问题、讲故事或者制作艺术品。毫无疑问，编程与写作也很像；问题是更像诗歌还是散文。如果编程像音乐的话，不管怎么样它都应该是爵士乐。</p><p>或许对我们每天所做工作最近似的类比来自中东民间故事：打开任何版本的《一千零一夜 (<span lang=ar>أَلْف لَيْلَة وَلَيْلَة</span>) 》，你会找到对一种被称作<dfn>镇尼</dfn>、<dfn>杰尼</dfn>、<dfn>精灵</dfn>或者 🧞 的神奇生物的描述。不管你怎么称呼它们，你一定熟悉它们实现愿望的习惯，和必然会引起的不幸。</p><p>从许多方面来看，电脑是抽象的愿望满足机的物理体现。像精灵一样，电脑会开心的执行任何你告诉它要做的事，而不会考虑你真正的意图是什么。之后当你意识到自己的错误时，就已经太晚了。</p><p>作为一个 Swift 开发者，很有可能你遇到过整数类型转换错误并想着「我希望这些警告赶紧消失，代码能编译通过」。</p><p>如果这听起来很熟悉，那你会对学习 <code>numbericCast(_:)</code> 感到高兴，它是 Swift Standard Libray 中一个小小的实用函数，有可能正是你所希望的。但是请小心提出你的愿望，它有可能马上会成真。</p><hr><p>让我们从消除觉得 <code>numericCast(_:)</code> 有什么魔法开始，通过<a href=https://github.com/apple/swift/blob/7f7b4f12d3138c5c259547c49c3b41415cd4206e/stdlib/public/core/Integers.swift#L3508-L3510>查看它的实现</a>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>numericCast</span>&lt;T : BinaryInteger, U : BinaryInteger&gt;(<span style=color:#66d9ef>_</span> x: T) -&gt; U {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> U(x)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>（像从<a href=/never>我们有关 <code>Never</code> 的文章</a>里学到的一样，极小量的 Swift 代码也能有巨大的作用。）</p><p>Swift 4 推出的 <a href=https://developer.apple.com/documentation/swift/binaryinteger><code>BinaryInteger</code></a> 协议，作为语言中整个数字实现的一部分。它提供了与整数工作的统一接口，包括有符号和无符号，还有所有的结构和大小。</p><p>当你将一个整数值转换为另一个类型时，另一个类型有可能无法表示这个值。这会发生在你尝试将一个有符号整数转换成一个无符号整数时（比如将 <code>-42</code> 转换为 <code>UInt</code>）或者数值超过了目标类型所能表示的范围时（比如 <code>UInt8</code> 只能表示 <code>0</code> 到 <code>255</code> 之间的数字）。</p><p><code>BinaryInteger</code> 为整数类型转换定义了四种策略，每一种在处理超出范围的值时都有不同行为：</p><ul><li><strong>范围检查转换</strong>（<a href=https://developer.apple.com/documentation/swift/binaryinteger/2885704-init><code>init(_:)</code></a>）：
遇到超出范围的值时触发运行时错误</li><li><strong>准确转换</strong>（<a href=https://developer.apple.com/documentation/swift/binaryinteger/2925955-init><code>init?(exactly:)</code></a>）：
遇到超出范围的值时返回 <code>nil</code></li><li><strong>钳制转换</strong>（<a href=https://developer.apple.com/documentation/swift/binaryinteger/2886143-init><code>init(clamping:)</code></a>）：
遇到超出范围的值时使用最近可表示的值</li><li><strong>位模式转换</strong>（<a href=https://developer.apple.com/documentation/swift/binaryinteger/2925529-init><code>init(truncatingIfNeeded:)</code></a>）：
截断至目标整数类型宽度</li></ul><p>正确的转换策略取决于使用时的情况。有些时候，希望能钳制数值到可表示的范围；有些时候，最好不要获取到任何值。对于 <code>numbericCast(_:)</code> 来说，它为了方便使用了范围检查转换。缺点就是使用超过范围的数值调用这个函数会导致运行时错误（具体来说，在 <code>-O</code> 和 <code>-Onone</code> 时陷入溢出错误）。</p><p>更多有关 Swift 4 中数字实现改变的信息，请查阅 <a href=https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md>SE-0104: &ldquo;Protocol-oriented integers&rdquo;</a>。</p><p>这个主题也在<a href=https://juejin.im/book/5b260350e51d4558c2322fbe>《Swift 数字详解》</a>中有更详细的讨论。</p><h2 id=字面地思考批判地思考>字面地思考，批判地思考</h2><p>在更进一步之前，让我们先来谈论一下整数字面量。</p><p><a href=https://nshipster.com/swift-literals/>我们在之前的文章讨论过</a>，Swift 提供了一个方便且可扩展的方式来在源代码中表示值。当和语言中的类型推断一起使用时，它们通常「可以工作」……这样一切都很好，但是当它们「无法工作」时就非常令人困惑了。</p><p>考虑下面的例子，有符号整型数组和无符号整型数组使用同样的字面量初始化：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> arrayOfInt: [Int] = [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> arrayOfUInt: [UInt] = [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>]
</span></span></code></pre></div><p>尽管它们好像是相等的，但我们不能做下面例子中的事情：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>arrayOfInt <span style=color:#66d9ef>as</span> [UInt] <span style=color:#75715e>// Error: Cannot convert value of type &#39;[Int]&#39; to type &#39;[UInt]&#39; in coercion</span>
</span></span></code></pre></div><p>解决这个问题的一种方式是，将 <code>numericCast</code> 函数作为参数传入 <code>map(_:)</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>arrayOfInt.map(numericCast) <span style=color:#66d9ef>as</span> [UInt]
</span></span></code></pre></div><p>这样等同于直接传入 <code>UInt</code> 范围检查构造器：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>arrayOfInt.map(UInt.<span style=color:#66d9ef>init</span>)
</span></span></code></pre></div><p>让我们再看一次这个例子，这次使用稍微不同的数值：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> arrayOfNegativeInt: [Int] = [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>arrayOfNegativeInt.map(numericCast) <span style=color:#66d9ef>as</span> [UInt] <span style=color:#75715e>// 🧞‍ Fatal error: Negative value is not representable</span>
</span></span></code></pre></div><p>作为一个编译时类型功能的运行时近似物，<code>numericCast(_:)</code> 更像是 <code>as!</code> 而不是 <code>as</code> 或 <code>as?</code>。</p><p>将这个和传入精确转换构造器 <code>init?(exactly:)</code> 的结果相比：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> arrayOfNegativeInt: [Int] = [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>arrayOfNegativeInt.map(UInt.<span style=color:#66d9ef>init</span>(exactly:)) <span style=color:#75715e>// [nil, nil, nil]</span>
</span></span></code></pre></div><p><code>numericCast(_:)</code>，像它内在的范围检查转换一样，是一个钝器，当你决定使用它时，明白你在权衡什么是非常重要的。</p><h2 id=正确的代价>正确的代价</h2><p>在 Swift 中，通常指导是为整数值使用 <code>Int</code>（且为浮点值使用 <code>Double</code>），除非有<strong>非常</strong>好的理由来使用更具体的类型。尽管 <code>Collection</code> 的 <code>count</code> 在定义上是非负的，但我们使用 <code>Int</code> 而不是 <code>UInt</code>。因为在与其他 API 交互时转换来转换去类型的代价要比更精确类型带来的好处要大。同样的原因，用 <code>Int</code> 来表示小数字几乎总是会更好，比如<a href=https://nshipster.com/datecomponents>工作日数字</a>，尽管它所有的可能值用一个 8 位整型存储都绰绰有余。</p><p>理解这个实践最好的方式就是在 Swift 里和 C API 对话几分钟。</p><p>古老且低级的 C API 里充斥着体系结构相关的类型定义和细微调整过的值存储空间。独立的来看，它们是可管理的。但从像头文件到指针这些互操作性麻烦上看，它们对某些问题可能会是一个断点（我不是在说调试中那种）。</p><p>当你看红色看到烦，只想要编译通过时，<code>numericCast(_:)</code> 就在那等着你。</p><h2 id=编译的随机性>编译的随机性</h2><p>很多人应该会熟悉<a href=https://developer.apple.com/documentation/swift/2884564-numericcast>官方文档中的例子</a>：</p><p>在 <a href=https://github.com/apple/swift-evolution/blob/master/proposals/0202-random-unification.md>SE-0202</a> 之前，（在苹果的平台上）Swift 中生成随机数的标准实践需要引入 <code>Darwin</code> 框架然后调用 <code>arc4random_uniform(3)</code> 函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>uint32_t</span> <span style=color:#a6e22e>arc4random_uniform</span>(<span style=color:#66d9ef>uint32_t</span> __upper_bound)
</span></span></code></pre></div><p>在 Swift 中使用 <code>arc4random</code> 需要进行不止一次而是两次类型转换：一是上限参数（<code>Int</code> → <code>UInt32</code>），二是返回值（<code>UInt32</code> → <code>Int</code>）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>Darwin</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>random</span>(<span style=color:#66d9ef>in</span> range: Range&lt;Int&gt;) -&gt; Int {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> Int(arc4random_uniform(UInt32(range.count))) <span style=color:#f92672>+</span> range.lowerBound
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>真恶心。</strong></p><p>通过使用 <code>numericCast(_:)</code>，我们可以让代码更可读一些，尽管也会变长一点：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>Darwin</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>random</span>(<span style=color:#66d9ef>in</span> range: Range&lt;Int&gt;) -&gt; Int {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> numericCast(arc4random_uniform(numericCast(range.count))) <span style=color:#f92672>+</span> range.lowerBound
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这里 <code>numericCast(_:)</code> 没有做任何类型合适的构造器做不到的事情。它的作用是指明这个转换是敷衍的——为了让代码编译需要做的最少的事情。</p><p>不过从前言有关精灵的事情中学到，我们应该谨慎的对待我们的愿望。</p><p>经过仔细检查，上面对例子中对 <code>numericCast(_:)</code> 的使用有一个明显的缺陷：<strong>当值超过 <code>UInt32.max</code> 时会造成崩溃！</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>random(<span style=color:#66d9ef>in</span>: <span style=color:#ae81ff>0.</span>.&lt;<span style=color:#ae81ff>0x1_0000_0000</span>) <span style=color:#75715e>// 🧞‍ Fatal error: Not enough bits to represent the passed value</span>
</span></span></code></pre></div><p>如果我们查看现在 <code>Int.random(in: 0...10)</code> <a href=https://github.com/apple/swift/blob/7f7b4f12d3138c5c259547c49c3b41415cd4206e/stdlib/public/core/Integers.swift#L2537-L2560>在 Swift Standard Library 中的实现</a>，可以看到其使用了钳制转换而不是类型检查转换。并且<a href=https://github.com/apple/swift/blob/7f7b4f12d3138c5c259547c49c3b41415cd4206e/stdlib/public/core/Random.swift#L156-L177>从一个随机字节缓冲区中取值</a>而不是委托给像 <code>arc4random_uniform</code> 这样的简便函数。</p><hr><p>编译通过的代码和正确的代码是不一样的。但有时候需要通过前者来最终获得后者。审慎的使用，<code>numericCast(_:)</code> 会是一个方便且能快速解决问题的工具。和类型转换构造器相比它还有表明潜在异常行为的好处。</p><p>根本上来说，编程就是<strong>准确</strong>描述我们想要怎么样——通常伴随艰苦的细节。并没有一个和精灵似的「做正确的事情」 CPU 指令（就算有的话，<a href=ttps://github.com/FixIssue/FixCode>我们能信赖它吗</a>？）。幸好，Swift 可以让我们比其他很多语言更安全和简洁的做这些事情。老实说，谁还能要求更多呢？</p><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2018-10-15 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mattt 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Swift target=_blank>Swift</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>