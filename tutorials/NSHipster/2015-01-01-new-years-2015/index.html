<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>Reader Submissions - New Year's 2015</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="Reader Submissions - New Year's 2015,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="Reader Submissions - New Year's 2015,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>Reader Submissions - New Year's 2015</span><span class=btRight><span title="Author · 作者" class=author>Mattt</span> <span title="Translator · 翻译" class=author>April Peng</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p>当我们花些时间来回溯我们在过去一年的经历的时候，有一点是清楚的：对专业的苹果开发者来说，2014 年是一个令人难以置信的一年。在这么短的时间跨度内发生了这么多的事情，都记不得在 Swift 之前我们跟 Objective-C 的关系，或者还有什么 API 比 iOS 8 或 WatchKit 更让我们着迷。</p><p>这有一个 NSHipster 传统问题要问你们，亲爱的读者，<a href=https://gist.github.com/mattt/f00da093956f20945727>请把你在过去一年里最喜欢的技巧发送给我们</a>，我们会在新年假期后公布结果。这一年随着大量新发展的出现，无论从苹果还是整个社区，都为读者分享了很多的有趣花絮。</p><p>谢谢 <a href=https://github.com/cmyr>Colin Rofls</a>, <a href=https://github.com/0xced>Cédric Luthi</a>, <a href=https://github.com/fpillet>Florent Pillet</a>, <a href=https://github.com/hborders>Heath Borders</a>, <a href=https://github.com/zobkiw>Joe Zobkiw</a>, <a href=https://github.com/jonfriskics>Jon Friskics</a>, <a href=https://github.com/incanus>Justin Miller</a>, <a href=https://github.com/marcinmatczuk>Marcin Matczuk</a>, <a href=https://github.com/Konrad77>Mikael Konradsson</a>, <a href=https://github.com/NSProgrammer>Nolan O&rsquo;Brien</a>, <a href=https://github.com/CodaFi>Robert Widmann</a>, <a href=https://github.com/palewar>Sachin Palewar</a>, <a href=https://github.com/defagos>Samuel Defago</a>, <a href=https://github.com/bitops>Sebastian Wittenkamp</a>, <a href=https://github.com/shpakovski>Vadim Shpakovski</a>, 和 <a href=https://github.com/kazmasaurus>Zak Remer</a> 的贡献。</p><hr><h2 id=成员函数的秘密生活>成员函数的秘密生活</h2><p>来自 <a href=https://github.com/CodaFi>Robert Widmann</a>:</p><blockquote><p>在 Swift 的类和结构里，使用静态时成员函数类总是有下列类型：</p></blockquote><pre><code>Object -&gt; (Args) -&gt; Thing
</code></pre><p>比如，你可以用两种方式来对一个数组调用 <code>reverse()</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>].reverse()
</span></span><span style=display:flex><span>Array.reverse([<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>])()
</span></span></code></pre></div><h2 id=--来封装-c-strings><code>@( )</code> 来封装 C-Strings</h2><p>来自 <a href=https://github.com/defagos>Samuel Defago</a>:</p><blockquote><p>鉴于文字大部分是用数字和集合关联的，我常常忘记它们可以在 UTF8 下工作良好，并且编码了 <code>NULL</code>， 终结了 C-string，特别是当我使用运行时代码：</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSString <span style=color:#f92672>*</span>propertyAttributesString <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>@(</span>property_getAttributes(class_getProperty([NSObject <span style=color:#66d9ef>class</span>], <span style=color:#e6db74>&#34;description&#34;</span>))<span style=color:#ae81ff>)</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// T@&#34;NSString&#34;,R,C
</span></span></span></code></pre></div><h2 id=amibeingdebugged>AmIBeingDebugged</h2><p><a href=https://github.com/NSProgrammer>Nolan O&rsquo;Brien</a> 的 <a href=https://developer.apple.com/library/mac/qa/qa1361/_index.html>this Technical Q&amp;A document</a> 让我们对 <code>AmIBeingDebugged</code> 方法引起了关注：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;assert.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdbool.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/sysctl.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> Bool <span style=color:#a6e22e>AmIBeingDebugged</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mib[<span style=color:#ae81ff>4</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> kinfo_proc info;
</span></span><span style=display:flex><span>    size_t size <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(info);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    info.kp_proc.p_flag <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mib[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> CTL_KERN;
</span></span><span style=display:flex><span>    mib[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> KERN_PROC;
</span></span><span style=display:flex><span>    mib[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> KERN_PROC_PID;
</span></span><span style=display:flex><span>    mib[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> getpid();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sysctl(mib, <span style=color:#66d9ef>sizeof</span>(mib) <span style=color:#f92672>/</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>mib), <span style=color:#f92672>&amp;</span>info, <span style=color:#f92672>&amp;</span>size, NULL, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (info.kp_proc.p_flag <span style=color:#f92672>&amp;</span> P_TRACED) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=使用惰性变量lazy-variables>使用惰性变量（Lazy Variables）</h2><p>来自 <a href=https://github.com/cmyr>Colin Rofls</a>:</p><blockquote><p>避免使用 optional。应尽量避免对 optional 进行隐式拆包（implicitly unwraped）。要声明一个变量，但不一定在初始化时赋初始值？就用惰性关键字，在你真的有值之前不调用 getter 方法。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>lazy</span> <span style=color:#66d9ef>var</span> someModelStructure = ExpensiveClass()
</span></span></code></pre></div><blockquote><p>如果你对这个变量调用 <code>set</code> 之前没有调用过 getter，惰性表达式永远不会被执行。比如在视图里直到 viewDidLoad 之前你都不一定要初始化就很棒。</p></blockquote><h2 id=访问添加到-storyboard-的容器视图container-views里的子控制器child-controllers>访问添加到 Storyboard 的容器视图（container views）里的子控制器（child controllers）</h2><p>来自 <a href=https://github.com/shpakovski>Vadim Shpakovski</a>:</p><blockquote><p>有一种方便的方式来访问插入到 storyboard 容器视图的子控制器：</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#75715e>// 1. A property has the same name as a segue identifier in XIB
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>) ChildViewController1 <span style=color:#f92672>*</span>childController1;
</span></span><span style=display:flex><span><span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>) ChildViewController2 <span style=color:#f92672>*</span>childController2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// #pragma mark - UIViewController
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>prepareForSegue:</span>(UIStoryboardSegue <span style=color:#f92672>*</span>)segue
</span></span><span style=display:flex><span>                 <span style=color:#a6e22e>sender:</span>(<span style=color:#66d9ef>id</span>)sender
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    [super prepareForSegue:segue sender:sender];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. All known destination controllers assigned to properties
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> ([self respondsToSelector:NSSelectorFromString(segue.identifier)]) {
</span></span><span style=display:flex><span>        [self setValue:segue.destinationViewController forKey:segue.identifier];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>viewDidLoad</span> {
</span></span><span style=display:flex><span>    [super viewDidLoad];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. Controllers already available bc viewDidLoad is called after prepareForSegue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    self.childController1.view.backgroundColor <span style=color:#f92672>=</span> [UIColor redColor];
</span></span><span style=display:flex><span>    self.childController2.view.backgroundColor <span style=color:#f92672>=</span> [UIColor blueColor];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=不需要重新编译的重新运行>不需要重新编译的重新运行</h2><p>来自 <a href=https://github.com/hborders>Heath Borders</a>:</p><blockquote><p>如果你一遍又一遍的调试同样的问题，你可以不重新编译就运行你的应用程序: &ldquo;Product > Perform Action > Run without Building&rdquo; (<code>⌘⌃R</code>)。</p></blockquote><h2 id=快速访问-playground-资源>快速访问 Playground 资源</h2><p>来自 <a href=https://github.com/jonfriskics>Jon Friskics</a>:</p><blockquote><p>Swift Playgrounds 跟所有的共享 Playground 数据都在 <code>/Users/HOME/Documents/Shared Playground Data</code> 下可以找到。</p></blockquote><blockquote><p>如果你喜欢使用很多的 Playgrounds，你会想要把各 Playground 使用到的数据放到该共享文件夹的子文件夹里面，但你得让 Playground 知道去哪里找。下面是我使用的辅助方法来让这事变得简单：</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>pathToFileInSharedSubfolder</span>(file: String) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> XCPSharedDataDirectoryPath <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/&#34;</span> <span style=color:#f92672>+</span> NSProcessInfo.processInfo().processName <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/&#34;</span> <span style=color:#f92672>+</span> file
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>在 NSProcessInfo 的 processName 属性包含了 Playground 文件的名称，所以只要你已经在 Playground 的共享数据文件夹里创建了用相同名字命名的子文件夹，就可以很容易的访问这些文件，就像读本地的 JSON 一样：</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>var</span> jsonReadError:NSError?
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> jsonData = NSFileManager.defaultManager().contentsAtPath(pathToFileInSharedSubfolder(<span style=color:#e6db74>&#34;data.json&#34;</span>))<span style=color:#f92672>!</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> jsonArray = NSJSONSerialization.JSONObjectWithData(jsonData, options: <span style=color:#66d9ef>nil</span>, error: &amp;jsonReadError) <span style=color:#66d9ef>as</span> [AnyObject]
</span></span></code></pre></div><blockquote><p>&mldr;或者得到一个本地图片：</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> imageView = UIImageView()
</span></span><span style=display:flex><span>imageView.image = UIImage(contentsOfFile: pathToFileInSharedSubfolder(<span style=color:#e6db74>&#34;image.png&#34;</span>))
</span></span></code></pre></div><hr><p>今年其余的读者意见的来自 <a href=https://github.com/0xced>Cédric Luthi</a>，他（像<a href=https://nshipster.com/new-years-2014/>去年</a>或<a href=https://nshipster.com/reader-submissions-new-years-2013/>之前</a>一样）贡献了很多的技巧和窍门值得占据一整篇文章。非常感谢，Cédric！</p><h2 id=揭露-cocoapods>揭露 CocoaPods!</h2><blockquote><p>有一个快速方法来检查（闭源）应用程序使用的所有源：</p></blockquote><p><code>$ class-dump -C Pods_ /Applications/Squire.app | grep -o "Pods_\w+"</code></p><h2 id=create_infoplist_section_in_binary><code>CREATE_INFOPLIST_SECTION_IN_BINARY</code></h2><blockquote><p>查看 Xcode 中对命令行应用程序的设置 <code>CREATE_INFOPLIST_SECTION_IN_BINARY</code>。它比 <code>-sectcreate__TEXT__info_plist</code> 链接标志（linker flag）更容易使用，而且它把处理了的 Info.plist 文件嵌入了到二进制包中。</p></blockquote><blockquote><p>这也是在归档雷达的教训。在2006年，此功能被要求以 <code>rdar://4722772</code> 归档，在 7 年后才被认真对待。</p></blockquote><h2 id=阻止-dylib-钩子>阻止 dylib 钩子</h2><blockquote><p><a href=https://twitter.com/dirk_gently/status/481075149437804544>来自 Sam Marshall 的这一招</a>使黑客的生活更艰难:> ></p></blockquote><blockquote><blockquote><p>把这一行加到你的 &ldquo;Other Linker Flags&rdquo; 里:</p></blockquote></blockquote><p><code>-Wl,-sectcreate,__RESTRICT,__restrict,/dev/null</code></p><h2 id=nsbundle--preferredlocalizations>NSBundle -preferredLocalizations</h2><blockquote><p>有时候，你需要知道你的应用程序在什么语言环境下运行。通常，人们会用 <code>NSLocale +preferredLanguages</code>。不幸的是这除了告诉你应用程序实际上显示的语言之外一无所知。它只是给你 iOS 中 &ldquo;Settings → General → Language & Region → Preferred Language&rdquo; 或是 OS X 里 &ldquo;System Preferences → Language & Region → Preferred Languages&rdquo; 同样的有序列表。</p></blockquote><blockquote><p>想象一下如果首选语言顺序是 <code>{英语, 法语}</code> 但是你的应用程序只支持德语。调用 <code>[NSLocale preferredLanguages] firstObject]</code> 会返回英语而不是你想要的德语。</p></blockquote><blockquote><p>得到应用程序使用的准确语言环境的正确方式是使用 <code>[[NSBundle mainBundle] preferredLocalizations]</code>。</p></blockquote><p>文档是这么说的：</p><blockquote><blockquote><p>一个 <code>NSString</code> 对象的数组包含了 bundle 里的区域语言 ID。这些字符串是按用户系统设置和可用本地化来排序的。</p></blockquote></blockquote><p><code>NSBundle.h</code> 里的注释说：</p><blockquote><blockquote><p>这个 bundle 本地化的子集，会对这个进程的当前执行环境的优先顺序上重新排序；主 bundle 的首选本地化显示了用户是最有可能在 UI 看到的语言（文本）</p></blockquote></blockquote><blockquote><p>你大概还需要使用 <code>NSLocale +canonicalLanguageIdentifierFromString:</code> 来确保规范的语言标识。</p></blockquote><h2 id=保护-sdk-头文件>保护 SDK 头文件</h2><blockquote><p>如果你是从 dmg 里安装的 Xcode，参考一下<a href=https://twitter.com/joar_at_work/statuses/472986684196278272>这个来自 Joar Wingfors 的方法</a>，通过保留所有权、权限和硬链接的方式避免不小心修改了 SDK 的头文件：</p></blockquote><p><code>$ sudo ditto /Volumes/Xcode/Xcode.app /Applications/Xcode.app</code></p><h2 id=检查-void--的实例变量>检查 <code>void *</code> 的实例变量</h2><blockquote><p>因为逆向工程的原因，非常有用的常用方法是查看对象的实例变量。它通常很容易通过 <code>valueForKey:</code> 来达成，因为很少有类会重写 <code>+accessInstanceVariablesDirectly</code> 来禁止变量通过 Key-Value Coding 访问。</p></blockquote><blockquote><p>但是有一种情况会让这个不起作用：当变量有一个 <code>void *</code> 类型的时候。</p></blockquote><blockquote><p>这有一个来自 iOS 6.1 里 MediaPlayer 库的摘录：</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>MPMoviePlayerController</span> : <span style=color:#a6e22e>NSObject</span> <span style=color:#f92672>&lt;</span>MPMediaPlayback<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>_internal;    <span style=color:#75715e>// 4 = 0x4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>BOOL</span> _readyForDisplay;  <span style=color:#75715e>// 8 = 0x8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><blockquote><p>由于 <code>id internal = [moviePlayerController valueForKey:@"internal"]</code> 不工作，有一个硬编码的方式访问内部变量：</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>id</span> internal <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>((<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>id</span><span style=color:#f92672>*</span>)(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)((uintptr_t)moviePlayerController <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>Class</span>)));
</span></span></code></pre></div><blockquote><p>不要发布这样的代码，这是非常不可靠的，因为变量布局可能会改变。只在逆向工程里使用！</p></blockquote><h2 id=nsdateformatter-dateformatfromtemplateoptionslocale><code>NSDateFormatter +dateFormatFromTemplate:options:locale:</code></h2><blockquote><p>友情提示：如果你在使用 <code>NSDateFormatter -setDateFormat:</code> 而不同时使用 <code>NSDateFormatter +dateFormatFromTemplate:options:locale:</code> 那么你很可能做错了。</p></blockquote><blockquote><p><a href=https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSDateFormatter_Class/#//apple_ref/occ/clm/NSDateFormatter/dateFormatFromTemplate:options:locale>文档</a>是这样的：</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>+ (NSString <span style=color:#f92672>*</span>)<span style=color:#a6e22e>dateFormatFromTemplate:</span>(NSString <span style=color:#f92672>*</span>)template
</span></span><span style=display:flex><span>                             <span style=color:#a6e22e>options:</span>(NSUInteger)opts
</span></span><span style=display:flex><span>                              <span style=color:#a6e22e>locale:</span>(NSLocale <span style=color:#f92672>*</span>)locale
</span></span></code></pre></div><blockquote><blockquote><p>不同的语言对时间要素有不同的规范。你用这个方法来得到某个特定语言（通常使用当前的语言 - 参看 currentLocale）给定的时间要素的正确字符串格式。</p></blockquote></blockquote><blockquote><blockquote><p>下面的例子展示了时间在英国英语和美国英语下的不同格式：</p></blockquote></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSLocale <span style=color:#f92672>*</span>usLocale <span style=color:#f92672>=</span> [[NSLocale alloc] initWithLocaleIdentifier:<span style=color:#e6db74>@&#34;en_US&#34;</span>];
</span></span><span style=display:flex><span>NSLocale <span style=color:#f92672>*</span>gbLocale <span style=color:#f92672>=</span> [[NSLocale alloc] initWithLocaleIdentifier:<span style=color:#e6db74>@&#34;en_GB&#34;</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>NSString <span style=color:#f92672>*</span>dateFormat;
</span></span><span style=display:flex><span>NSString <span style=color:#f92672>*</span>dateComponents <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;yMMMMd&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dateFormat <span style=color:#f92672>=</span> [NSDateFormatter dateFormatFromTemplate:dateComponents options:<span style=color:#ae81ff>0</span> locale:usLocale];
</span></span><span style=display:flex><span>NSLog(<span style=color:#e6db74>@&#34;Date format for %@: %@&#34;</span>,
</span></span><span style=display:flex><span>    [usLocale displayNameForKey:NSLocaleIdentifier value:[usLocale localeIdentifier]], dateFormat);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dateFormat <span style=color:#f92672>=</span> [NSDateFormatter dateFormatFromTemplate:dateComponents options:<span style=color:#ae81ff>0</span> locale:gbLocale];
</span></span><span style=display:flex><span>NSLog(<span style=color:#e6db74>@&#34;Date format for %@: %@&#34;</span>,
</span></span><span style=display:flex><span>    [gbLocale displayNameForKey:NSLocaleIdentifier value:[gbLocale localeIdentifier]], dateFormat);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Output:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Date format for English (United States): MMMM d, y
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Date format for English (United Kingdom): d MMMM y
</span></span></span></code></pre></div><h2 id=调试器中得到内部常量>调试器中得到内部常量</h2><blockquote><p>最近，<a href=https://twitter.com/myell0w/>Matthias Tretter</a> 在 Twitter 上提问：</p></blockquote><blockquote class=twitter-tweet lang=en><p>有没有人知道在 iOS 8 里面默认的动画时长和使 viewController 用模型方式展示的触发条件？</p>&mdash; Matthias Tretter (@myell0w) <a href=https://twitter.com/myell0w/status/535775373729234944>November 21, 2014</a></blockquote><script async src=//platform.twitter.com/widgets.js></script><blockquote><p>在 UIKit 的类堆栈里搜索 duration，找到了 <code>UITransitionView +defaultDurationForTransition:</code> 方法，然后在那个方法上加个断点：</p></blockquote><pre tabindex=0><code>(lldb) br set -n &#34;+[UITransitionView defaultDurationForTransition:]&#34;
</code></pre><blockquote><p>展示一个模式视图控制器，就会进到这个断点，键入 <code>finish</code> 来执行这个方法：</p></blockquote><pre tabindex=0><code>(lldb) finish
</code></pre><blockquote><p>在 <code>defaultDurationForTransition:</code> 执行的那个断点，你可以读到结果（在 <code>xmm0</code> 里）：</p></blockquote><pre tabindex=0><code>(lldb) register read xmm0 --format float64
    xmm0 = {0.4 0}
</code></pre><blockquote><p>答案：默认时长是 0.4 秒。</p></blockquote><h2 id=diy-弱关联对象>DIY 弱关联对象</h2><blockquote><p>遗憾的是，关联对象 <code>OBJC_ASSOCIATION_ASSIGN</code> 的政策不支持零弱引用（zeroing weak references）。幸运的是，自己实现也很简单。你只需一个简单的类来封装一个弱引用的对象：</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>WeakObjectContainter</span> : <span style=color:#a6e22e>NSObject</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>readonly</span>, <span style=color:#66d9ef>weak</span>) <span style=color:#66d9ef>id</span> object;
</span></span><span style=display:flex><span><span style=color:#66d9ef>@end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@implementation</span> <span style=color:#a6e22e>WeakObjectContainter</span>
</span></span><span style=display:flex><span>- (<span style=color:#66d9ef>instancetype</span>)<span style=color:#a6e22e>initWithObject:</span>(<span style=color:#66d9ef>id</span>)object {
</span></span><span style=display:flex><span>    self <span style=color:#f92672>=</span> [super init];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>self) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> nil;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    self.object <span style=color:#f92672>=</span> object;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> self;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>@end</span>
</span></span></code></pre></div><blockquote><p>然后，用 <code>OBJC_ASSOCIATION_RETAIN(_NONATOMIC):</code> 关联 <code>WeakObjectContainter</code></p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>objc_setAssociatedObject(self, <span style=color:#f92672>&amp;</span>MyKey, [[WeakObjectContainter alloc] initWithObject:object], OBJC_ASSOCIATION_RETAIN_NONATOMIC);
</span></span></code></pre></div><blockquote><p>用 <code>object</code> 属性来访问它以使得把零弱引用关联到需要的对象上：</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>id</span> object <span style=color:#f92672>=</span> [objc_getAssociatedObject(self, <span style=color:#f92672>&amp;</span>MyKey) object];
</span></span></code></pre></div><hr><p>就是这样，我们迎来了全新的充满可能和机会的一年。大家 2015 年快乐！</p><p>祝愿你继续编译你的代码并且得到鼓舞。</p><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2015-01-01 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mattt 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Swift target=_blank>Swift</a></li><li><a class=link href=https://autoptr.top/categories/Objective-C target=_blank>Objective-C</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>