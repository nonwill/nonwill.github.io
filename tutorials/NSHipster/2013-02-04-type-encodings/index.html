<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>Type Encodings</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="Type Encodings,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="Type Encodings,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>Type Encodings</span><span class=btRight><span title="Author · 作者" class=author>Mattt</span> <span title="Translator · 翻译" class=author>Ricky Tan</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p>从 <a href=https://en.wikipedia.org/wiki/Numbers_station>数字电台</a> 和 <a href=https://en.wikipedia.org/wiki/Numerology>数学命理</a> 到 <a href=https://en.wikipedia.org/wiki/Egyptian_hieroglyphs>象形文字</a> 和 <a href=https://en.wikipedia.org/wiki/Hobo#Hobo_.28sign.29_code>流浪汉码</a>，找到看似平常的东西中隐藏的意思真是令人着迷。即使它们中隐藏的信息很少用到或者并不特别有趣，但正是那种寻找的快感激发着我们强烈的好奇心。</p><p>在这种精神下，本周的 NSHipster 我们来看看 <a href=https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html>Objective-C Type Encodings</a>。</p><hr><p><a href=https://nshipster.cn/nsvalue/>上一周</a>，在讨论 <code>NSValue</code> 时提到了 <code>+valueWithBytes:objCType:</code>，它的第二个参数需要用 Objective-C 的编译器指令 <code>@encode()</code> 来创建。</p><p><code>@encode</code>，<a href=https://nshipster.com/at-compiler-directives/><code>@</code>编译器指令</a> 之一，返回一个给定类型编码为一种内部表示的字符串（例如，<code>@encode(int)</code> → <code>i</code>），类似于 ANSI C 的 <code>typeof</code> 操作。苹果的 Objective-C 运行时库内部利用类型编码帮助加快消息分发。</p><p>这里有一个所有不同的 Objective-C 类型编码的概要：</p><table id=type-encodings><caption>Objective-C Type Encodings</caption><thead><tr><th>编码</th><th>意义</th></tr></thead><tbody><tr><td><tt>c</tt></td><td>A <tt>char</tt></td></tr><tr><td><tt>i</tt></td><td>An <tt>int</tt></td></tr><tr><td><tt>s</tt></td><td>A <tt>short</tt></td></tr><tr><td><tt>l</tt></td><td>A <tt>long</tt><tt>l</tt> is treated as a 32-bit quantity on 64-bit programs.</td></tr><tr><td><tt>q</tt></td><td>A <tt>long long</tt></td></tr><tr><td><tt>C</tt></td><td>An <tt>unsigned char</tt></td></tr><tr><td><tt>I</tt></td><td>An <tt>unsigned int</tt></td></tr><tr><td><tt>S</tt></td><td>An <tt>unsigned short</tt></td></tr><tr><td><tt>L</tt></td><td>An <tt>unsigned long</tt></td></tr><tr><td><tt>Q</tt></td><td>An <tt>unsigned long long</tt></td></tr><tr><td><tt>f</tt></td><td>A <tt>float</tt></td></tr><tr><td><tt>d</tt></td><td>A <tt>double</tt></td></tr><tr><td><tt>B</tt></td><td>A C++ <tt>bool</tt> or a C99 <tt>_Bool</tt></td></tr><tr><td><tt>v</tt></td><td>A <tt>void</tt></td></tr><tr><td><tt>*</tt></td><td>A character string (<tt>char *</tt>)</td></tr><tr><td><tt>@</tt></td><td>An object (whether statically typed or typed <tt>id</tt>)</td></tr><tr><td><tt>#</tt></td><td>A class object (<tt>Class</tt>)</td></tr><tr><td><tt>:</tt></td><td>A method selector (<tt>SEL</tt>)</td></tr><tr><td>[<em>array type</em>]</td><td>An array</td></tr><tr><td>{<em>name=type...</em>}</td><td>A structure</td></tr><tr><td>(<em>name</em>=<em>type...</em>)</td><td>A union</td></tr><tr><td><tt>b</tt>num</td><td>A bit field of <em>num</em> bits</td></tr><tr><td><tt>^</tt>type</td><td>A pointer to <em>type</em></td></tr><tr><td><tt>?</tt></td><td>An unknown type (among other things, this code is used for function pointers)</td></tr></tbody></table><p>当然，用图表很不错，但是用代码实践更好：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSLog(<span style=color:#e6db74>@&#34;int        : %s&#34;</span>, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>NSLog(<span style=color:#e6db74>@&#34;float      : %s&#34;</span>, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>float</span>));
</span></span><span style=display:flex><span>NSLog(<span style=color:#e6db74>@&#34;float *    : %s&#34;</span>, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span>));
</span></span><span style=display:flex><span>NSLog(<span style=color:#e6db74>@&#34;char       : %s&#34;</span>, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>char</span>));
</span></span><span style=display:flex><span>NSLog(<span style=color:#e6db74>@&#34;char *     : %s&#34;</span>, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>));
</span></span><span style=display:flex><span>NSLog(<span style=color:#e6db74>@&#34;BOOL       : %s&#34;</span>, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>BOOL</span>));
</span></span><span style=display:flex><span>NSLog(<span style=color:#e6db74>@&#34;void       : %s&#34;</span>, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>void</span>));
</span></span><span style=display:flex><span>NSLog(<span style=color:#e6db74>@&#34;void *     : %s&#34;</span>, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>NSLog(<span style=color:#e6db74>@&#34;NSObject * : %s&#34;</span>, <span style=color:#66d9ef>@encode</span>(NSObject <span style=color:#f92672>*</span>));
</span></span><span style=display:flex><span>NSLog(<span style=color:#e6db74>@&#34;NSObject   : %s&#34;</span>, <span style=color:#66d9ef>@encode</span>(NSObject));
</span></span><span style=display:flex><span>NSLog(<span style=color:#e6db74>@&#34;[NSObject] : %s&#34;</span>, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>typeof</span>([NSObject <span style=color:#66d9ef>class</span>])));
</span></span><span style=display:flex><span>NSLog(<span style=color:#e6db74>@&#34;NSError ** : %s&#34;</span>, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>typeof</span>(NSError <span style=color:#f92672>**</span>)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> intArray[<span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>};
</span></span><span style=display:flex><span>NSLog(<span style=color:#e6db74>@&#34;int[]      : %s&#34;</span>, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>typeof</span>(intArray)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> floatArray[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0.1f</span>, <span style=color:#ae81ff>0.2f</span>, <span style=color:#ae81ff>0.3f</span>};
</span></span><span style=display:flex><span>NSLog(<span style=color:#e6db74>@&#34;float[]    : %s&#34;</span>, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>typeof</span>(floatArray)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> _struct {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>short</span> a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> c;
</span></span><span style=display:flex><span>} Struct;
</span></span><span style=display:flex><span>NSLog(<span style=color:#e6db74>@&#34;struct     : %s&#34;</span>, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>typeof</span>(Struct)));
</span></span></code></pre></div><p>结果：</p><table><thead><tr><th>类型</th><th>编码</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>i</code></td></tr><tr><td><code>float</code></td><td><code>f</code></td></tr><tr><td><code>float *</code></td><td><code>^f</code></td></tr><tr><td><code>char</code></td><td><code>c</code></td></tr><tr><td><code>char *</code></td><td><code>*</code></td></tr><tr><td><code>BOOL</code></td><td><code>c</code></td></tr><tr><td><code>void</code></td><td><code>v</code></td></tr><tr><td><code>void *</code></td><td><code>^v</code></td></tr><tr><td><code>NSObject *</code></td><td><code>@</code></td></tr><tr><td><code>NSObject</code></td><td><code>#</code></td></tr><tr><td><code>[NSObject]</code></td><td><code>{NSObject=#}</code></td></tr><tr><td><code>NSError **</code></td><td><code>^@</code></td></tr><tr><td><code>int[]</code></td><td><code>[5i]</code></td></tr><tr><td><code>float[]</code></td><td><code>[3f]</code></td></tr><tr><td><code>struct</code></td><td><code>{_struct=sqQ}</code></td></tr></tbody></table><p>这里有一些特别需要注意的：</p><ul><li>指针的标准编码是加一个前置的 <code>^</code>，而 <code>char *</code> 拥有自己的编码 <code>*</code>。这在概念上是很好理解的，因为 C 的字符串被认为是一个实体，而不是指针。</li><li><code>BOOL</code> 是 <code>c</code>，而不是某些人以为的 <code>i</code>。原因是 <code>char</code> 比 <code>int</code> 小，且在 80 年代 Objective-C 最开始设计的时候，每一个 bit 位都比今天的要值钱（就像美元一样）。<code>BOOL</code> 更确切地说是 <code>signed char</code> （即使设置了 <code>-funsigned-char</code> 参数），以在不同编译器之间保持一致，因为 <code>char</code> 可以是 <code>signed</code> 或者 <code>unsigned</code>。</li><li>直接传入 <code>NSObject</code> 将产生 <code>#</code>。但是传入 <code>[NSObject class]</code> 产生一个名为 <code>NSObject</code> 只有一个类字段的结构体。很明显，那就是 <code>isa</code> 字段，所有的 <code>NSObject</code> 实例都用它来表示自己的类型。</li></ul><h2 id=方法编码>方法编码</h2><p>如苹果的 <a href=https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html>&ldquo;Objective-C Runtime Programming Guide&rdquo;</a> 中所提到的，有一大把内部使用的类型编码无法用 <code>@encode()</code> 返回。</p><p>以下是协议中声明的方法的类型修饰符：</p><table id=method-encodings><caption>Objective-C Method Encodings</caption><thead><tr><th>编码</th><th>意义</th></tr></thead><tbody><tr><td><tt>r</tt></td><td><tt>const</tt></td></tr><tr><td><tt>n</tt></td><td><tt>in</tt></td></tr><tr><td><tt>N</tt></td><td><tt>inout</tt></td></tr><tr><td><tt>o</tt></td><td><tt>out</tt></td></tr><tr><td><tt>O</tt></td><td><tt>bycopy</tt></td></tr><tr><td><tt>R</tt></td><td><tt>byref</tt></td></tr><tr><td><tt>V</tt></td><td><tt>oneway</tt></td></tr></tbody></table><p>对于那些熟悉 <a href=https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/Foundation/Classes/NSDistantObject_Class/Reference/Reference.html>NSDistantObject</a> 的人，你无疑会认出这些是 <a href=https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/DistrObjects/DistrObjects.html%23//apple_ref/doc/uid/10000102i>Distributed Objects</a> 的残留。</p><p>尽管 DO (Distributed Objects) 在 iOS 时代已经不那么时髦了，它仍是用于 Cocoa 应用程序进程间通信的协议————甚至用于网络上的不同机器之间。在这些约束下，上下文里附加的内容就带来了很多好处。</p><p>例如，分页式的对象消息的参数默认是用代理传递的。在那些没必要用到低效的代理的情况下，增加一个 <code>bycopy</code> 修饰符以保证发送了一份完整的拷贝。同样，默认情况下，带用 <code>inout</code> 的参数表明它在发消息时对象即可传入又可传出。将参数特别标注为 <code>in</code> 或 <code>out</code>，程序将避免一些来回的开销。</p><hr><p>我们从对 Objective-C 的类型编码的全新理解上能得到什么呢？
不瞒您说，其实没多少（除非你在做一些疯狂的元编程）。</p><p>但是就如我们最开始所说的，在追求破译密文的过程中要用到不少智慧。</p><p>看看类型编码为我们展现的有关 Objective-C 内部的细节，这本身就是一种高尚的追求。如果刨根问到底的话，我们需要了解一下 Distributed Objects 神秘的历史以及那 <a href=https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/Foundation/Classes/NSNumberFormatter_Class/Reference/Reference.html%23jumpTo_22>至今仍然存在</a> 的复杂的参数修饰符。</p><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2013-02-04 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mattt 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Objective-C target=_blank>Objective-C</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>