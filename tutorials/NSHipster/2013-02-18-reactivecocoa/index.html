<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>ReactiveCocoa</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="ReactiveCocoa,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="ReactiveCocoa,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>ReactiveCocoa</span><span class=btRight><span title="Author · 作者" class=author>Mattt</span> <span title="Translator · 翻译" class=author>Croath Liu</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p>编程语言是有生命的。语言在自由无方向迅速发展的生命周期中不断被推动、被挑战、被变得不规范化、或被蒙上了神秘面纱。科技在不停的改变中、在开发团队和开源社区不断来了又走中得以不断发展；隐晦的神秘力量凭借新兴项目的巨人肩膀被磨练得力量日益突出，很快就会在长期的蛰伏后觉醒，大力开辟出一片新天地。</p><p>Objective-C 在几十年间的非凡发展史可以分为四个阶段：</p><p><strong>第 1 阶段</strong>，NeXT 接手了 Objective-C 用以支持<a href=https://en.wikipedia.org/wiki/NeXTSTEP>NeXTSTEP</a>和<a href=https://en.wikipedia.org/wiki/Web_server#History>世界上第一个 web server</a>。</p><p><strong>第 2 阶段</strong>，苹果并购了 NeXT，（在与 Java 的长期拉锯战之后），Objective-C 处于苹果技术栈的核心地位。</p><p><strong>第 3 阶段</strong>，随着 iOS 系统的发布，Objective-C 上升到了空前重要的地位，成为移动计算领域最重要的语言。</p><p><strong>Objective-C 的第 4 阶段，也就是现如今</strong>，伴随着大批从 Ruby、Python、Javascript 社区转型的 iOS 工程师的涌入，Objective-C 开始在开源领域大放异彩。Objective-C 第一次直接被苹果以外的其他人打磨和引导。</p><p>打破了苹果 API 排他性的盾牌，本期 NSHipster 将介绍一个为 Objective-C 勇敢构建新纪元的开源项目：<a href=https://github.com/ReactiveCocoa/ReactiveCocoa>ReactiveCocoa</a>。</p><hr><blockquote><p>为了对 ReactiveCocoa 有全方位了解，请查看其项目的<a href=https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/README.md>README</a>、<a href=https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/FrameworkOverview.md>Framework Overview</a>和<a href=https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/DesignGuidelines.md>Design Guidelines</a>。</p></blockquote><p><a href=https://github.com/ReactiveCocoa/ReactiveCocoa>ReactiveCocoa</a>是一个将函数响应式编程范例带入 Objective-C 的开源库。由<a href=https://github.com/joshaber>Josh Abernathy</a>和<a href=https://github.com/jspahrsummers>Justin Spahr-Summers</a>在对<a href=http://mac.github.com>GitHub for Mac</a>的开发过程中建立。上周，ReactiveCocoa 发布了其<a href=https://github.com/ReactiveCocoa/ReactiveCocoa/tree/v1.0.0>1.0 release</a>，达到了第一个重要里程碑。</p><p><a href=https://en.wikipedia.org/wiki/Functional_reactive_programming>函数响应式编程(Functional Reactive Programming a.k.a FRP)</a>是思考软件将输入转化为输出在时间上的持续过程的一种方式。<a href=http://blog.maybeapps.com/post/42894317939/input-and-output>Josh Abernathy 这样解释它</a>：</p><blockquote><p>程序接收输入产生输出。输出就是对输入做了一些事的结果。输入，转换，输出，完成。</p><p>输入是应用动作的全部来源。点击、键盘事件、定时器事件、GPS 时间、网络请求响应都算是输入。这些事件被传递到应用中，应用将他们以某种方式混合，产生了结果：就是输出。</p><p>输出通常会改变应用的 UI。开关状态变化、列表有了新的元素都是 UI 变化。也有可能让磁盘上某个文件产生变化，或者产生一个 API 请求，这都是应用的输出。</p><p>但不像传统的输入输出设计，应用的输入输出可以产生很多次。应用打开后，不只是一个简单的 输入 → 工作 → 输出 就构成了一个生命周期。应用经常有大量的输入并基于这些输入产生输出。</p></blockquote><p>为了举例说明传统范式即 Objective-C 的命令响应式编程和函数响应式范式的区别，来思考一下下面这个判断注册项是否合法的常用样例：</p><h3 id=传统范式>传统范式</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>isFormValid</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [self.usernameField.text length] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>            [self.emailField.text length] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>            [self.passwordField.text length] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>            [self.passwordField.text isEqual:self.passwordVerificationField.text];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma mark - UITextFieldDelegate
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>textField:</span>(UITextField <span style=color:#f92672>*</span>)textField
</span></span><span style=display:flex><span><span style=color:#a6e22e>shouldChangeCharactersInRange:</span>(NSRange)range
</span></span><span style=display:flex><span><span style=color:#a6e22e>replacementString:</span>(NSString <span style=color:#f92672>*</span>)string
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    self.createButton.enabled <span style=color:#f92672>=</span> [self isFormValid];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> YES;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>传统范式的样例中，逻辑被放在了很多方法里，零碎地摆放在 view controller 里，通过到处散布到 delegate 里的<code>self.createButton.enabled = [self isFormValid];</code>方法在页面的生命周期中被调用。</p><p>比较一下用 ReactiveCocoa 写的同样功能的代码：</p><h3 id=reactivecocoa>ReactiveCocoa</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>RACSignal <span style=color:#f92672>*</span>formValid <span style=color:#f92672>=</span> [RACSignal
</span></span><span style=display:flex><span>  combineLatest:<span style=color:#ae81ff>@[</span>
</span></span><span style=display:flex><span>    self.username.rac_textSignal,
</span></span><span style=display:flex><span>    self.emailField.rac_textSignal,
</span></span><span style=display:flex><span>    self.passwordField.rac_textSignal,
</span></span><span style=display:flex><span>    self.passwordVerificationField.rac_textSignal
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>]</span>
</span></span><span style=display:flex><span>  reduce:<span style=color:#f92672>^</span>(NSString <span style=color:#f92672>*</span>username, NSString <span style=color:#f92672>*</span>email, NSString <span style=color:#f92672>*</span>password, NSString <span style=color:#f92672>*</span>passwordVerification) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>@(</span>[username length] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> [email length] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> [password length] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>&amp;&amp;</span> [password isEqual:passwordVerification]<span style=color:#ae81ff>)</span>;
</span></span><span style=display:flex><span>  }];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>RAC(self.createButton.enabled) <span style=color:#f92672>=</span> formValid;
</span></span></code></pre></div><p>所有对于判断表单输入是否合法的逻辑都被整合为一串逻辑了。每次不论哪个输入框被修改了，用户的输入都会被 reduce 成一个布尔值，然后就可以自动来控制注册按钮的可用状态了。</p><h2 id=概述>概述</h2><p>ReactiveCocoa 由两大主要部分组成：<a href=https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/FrameworkOverview.md#signals>signals</a> (<code>RACSignal</code>) 和 <a href=https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/FrameworkOverview.md#sequences>sequences</a> (<code>RACSequence</code>)。</p><p>signal 和 sequence 都是<a href=https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/FrameworkOverview.md#streams>streams</a>，他们共享很多相同的方法。ReactiveCocoa 在功能上做了语义丰富、一致性强的一致性设计：signal 是<em>push</em>驱动的 stream，sequence 是<em>pull</em>驱动的 stream。</p><h3 id=racsignal><code>RACSignal</code></h3><blockquote><ul><li><strong>异步控制或事件驱动的数据源</strong>：Cocoa 编程中大多数时候会关注用户事件或应用状态改变产生的响应。</li><li><strong>链式以来操作</strong>：网络请求是最常见的依赖性样例，前一个对 server 的请求完成后，下一个请求才能构建。</li><li><strong>并行独立动作</strong>：独立的数据集要并行处理，随后还要把他们合并成一个最终结果。这在 Cocoa 中很常见，特别是涉及到同步动作时。</li></ul></blockquote><blockquote><p>Signal 会触发它们的 subscriber 三种不同类型的事件：</p><ul><li><strong>下一个</strong>事件从 stream 中提供一个新值。不像 Cocoa 集合，它是完全可用的，甚至一个 signal 可以包含 <code>nil</code>。</li><li><strong>错误</strong>事件会在一个 signal 结束之前被标示出来这里有一个错误。这种事件可能包含一个 <code>NSError</code> 对象来标示什么发生了错误。错误必须被特殊处理——错误不会被包含在 stream 的值里面。</li><li><strong>完成</strong>事件标示 signal 成功结束，不会再有新的值会被加入到 stream 当中。完成事件也必须被单独控制——它不会出现在 stream 的值里面。</li></ul><p>一个 signal 的生命由很多<code>下一个(next)</code>事件和一个<code>错误(error)</code>或<code>完成(completed)</code>事件组成（后两者不同时出现）。</p></blockquote><h3 id=racsequence><code>RACSequence</code></h3><blockquote><ul><li><strong>简化集合转换</strong>：你会痛苦地发现 <code>Foundation</code> 库中没有类似 <code>map</code> 和 <code>filter</code>、<code>fold/reduce</code> 等高级函数。</li></ul></blockquote><blockquote><p>Sequence 是一种集合，很像 <code>NSArray</code>。但和数组不同的是，一个 sequence 里的值默认是<em>延迟</em>加载的（只有需要的时候才加载），这样的话如果 sequence 只有一部分被用到，那么这种机制就会提高性能。像 Cocoa 的集合类型一样，sequence 不接受 <code>nil</code> 值。</p><p><code>RACSequence</code> 允许任意 Cocoa 集合在统一且显式地进行操作。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>RACSequence <span style=color:#f92672>*</span>normalizedLongWords <span style=color:#f92672>=</span> [[words.rac_sequence
</span></span><span style=display:flex><span>    filter:<span style=color:#f92672>^</span> <span style=color:#66d9ef>BOOL</span> (NSString <span style=color:#f92672>*</span>word) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> [word length] <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    }]
</span></span><span style=display:flex><span>    map:<span style=color:#f92672>^</span>(NSString <span style=color:#f92672>*</span>word) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> [word lowercaseString];
</span></span><span style=display:flex><span>    }];
</span></span></code></pre></div><h2 id=cocoa-中的先例>Cocoa 中的先例</h2><p>Capturing and responding to changes has a long tradition in Cocoa, and ReactiveCocoa is a conceptual and functional extension of that. It is instructive to contrast RAC with those Cocoa technologies:</p><h3 id=rac-与-kvo>RAC 与 KVO</h3><p><a href=https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html>Key-Value Observing</a>是 Cocoa 所有魔法的核心，它被广泛应用在 ReactiveCocoa 对于属性变化的影响动作中。然而 KVO 用起来即不简单也不开心：它的 API 有很多过度设计的参数，以及缺乏方便的 block 方式调用。</p><h3 id=rac-与-bindings>RAC 与 Bindings</h3><p><a href=https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CocoaBindings/CocoaBindings.html>Bindings</a>也是黑魔法。</p><p>虽然对 OS X 控制的要点就是 Bindings，但是它的意义在近年来越来越没那么重要了，因为焦点已经移动到了 iOS 和 UIKit 这些 Bindings 不支持的东西身上。Bindings 替代了大量的模版胶水代码，允许在 Interface Builder 中完成编码，但严格上说还是比较有局限性的，并且_无法_debug。RAC 提供了一种简洁易懂、扩展性强的以代码为基础的 API 来运行在 iOS 上，目标就是取代所有在 OS X 能用 Bindings 实现的神奇功能。</p><hr><p>Objective-C 在 C 的核心上吸收了 Smalltalk 的思想建立而成，但哲学理念上已经超越了它原本来源的血统。</p><p><code>@protocol</code> 是对 C++多重继承的拒绝，顺应抽象数据的类型范式是对 Java <code>Interface</code>的吸收。Objective-C 2.0 引入了<code>@property / @synthesize</code>则灵感来自 C#的 <code>get; set;</code> 方法对 getter 和 setter 的速记（就语法上来说，这也是 NeXTSETP 强硬路线坚持者经常辩论的一点）。Block 给这门语言带来了函数式编程的好处，可以使用 Grand Central Dispatch——来自 Fortran / C / C++ standard <a href=https://en.wikipedia.org/wiki/OpenMP>OpenMP</a>思想而成的基于队列的并发 API。下标和对象字面量都是像 Ruby、Javascript 这样的脚本语言的标准特性，如今也由一个 Clang 插件被带入了 Objective-C 的世界里。</p><p>ReactiveCocoa 则给 Objective-C 带来了函数响应式编程的健康药剂。它本身也是受 C#的<a href=http://msdn.microsoft.com/en-us/data/gg577609.aspx>Rx library</a>、<a href=https://en.wikipedia.org/wiki/Clojure>Clojure</a>和<a href=https://en.wikipedia.org/wiki/Elm_(programming_language)>Elm</a>的影响发展而成。</p><p>好的点子会传染。ReactiveCocoa 就是一种警示，提醒人们好的点子也可以从看似不太可能的地方传播过来，这样的新鲜思想对解决类似的问题也会有完全不同的方法呢。</p><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2013-02-18 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mattt 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Open%20Source target=_blank>Open Source</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>