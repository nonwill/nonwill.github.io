<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>__attribute__</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="__attribute__,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="__attribute__,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>__attribute__</span><span class=btRight><span title="Author · 作者" class=author>Mattt</span> <span title="Translator · 翻译" class=author>Chester Liu</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p>本站点文章经常中出现的一个主题是，强调和编译器保持良好关系的重要性。和其他手艺一样，程序员的效率也取决于如何对待他们的工具。照顾好你的工具，它们也会照顾好你。</p><p><code>__attribute__</code> 是一个用于在声明时指定一些特性的编译器指令，它可以让我们进行更多的错误检查和高级优化工作。</p><p>使用这个关键字的语法是 <code>__attribute__</code> 后面跟两组括号（两个括号可以让它很容易在宏里面使用，特别是有多个属性的时候）。在括号里面是用逗号分隔的属性列表。<code>__attribute__</code> 指令可以放在函数，变量和类型声明之后。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#75715e>// Return the square of a number
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>square</span>(<span style=color:#66d9ef>int</span> n) __attribute__((<span style=color:#66d9ef>const</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Declare the availability of a particular API
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>  __attribute__((availability(macosx,introduced<span style=color:#f92672>=</span><span style=color:#ae81ff>10.4</span>,deprecated<span style=color:#f92672>=</span><span style=color:#ae81ff>10.6</span>)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Send printf-like message to stderr and exit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>die</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>format, ...)
</span></span><span style=display:flex><span>  __attribute__((noreturn, format(printf, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>)));
</span></span></code></pre></div><p>如果这个让你想起了 ISO C 当中的 <a href=https://nshipster.cn/pragma><code>#pragma</code></a>，并不是只有你一个人会这样想。</p><p>事实上，当 <code>__attribute__</code> 首次被引入 GCC 时就受到了一些人的反对，他们建议使用 <code>#pragma</code> 来完成同样的事情。</p><p>然而有两个原因导致最后 <code>__attribute__</code> 还是被添加进来了：</p><blockquote><ol><li>从宏中生成 <code>#pragma</code> 是不可能的（在 C99 引入 <code>_Pragma</code> 操作符之前）。</li><li>同样的 <code>#pragma</code> 语句在另外的编译器中的含义不能完全确定。</li></ol></blockquote><p>引用 <a href=http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html>GCC 函数属性有关文档</a> 的说法：</p><blockquote><p>这两个理由几乎能覆盖所有提议使用 <code>#pragma</code> 的申请。在任何地方使用 <code>#pragma</code> 基本都是错误的。</p></blockquote><p>确实如此，如果你看一下现代 Objective-C——在苹果框架的头文件以及精心设计的开源项目中—— 使用 <code>__attribute__</code> 的地方非常多。（相反，如今 <code>#pragma</code> 值得注意的地方只是用于修饰：<code>#pragma mark</code>）</p><p>话不多说，让我们看一下最重要的几个属性：</p><hr><h2 id=gcc>GCC</h2><h3 id=format><code>format</code></h3><blockquote><p><code>format</code> 属性用于指定一个函数接收类似 <code>printf</code>， <code>scanf</code>， <code>strftime</code> 和 <code>strfmon</code> 风格的参数，应该按照参数对格式化字符串进行类型检查。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>my_printf</span> (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>my_object, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>my_format, ...)
</span></span><span style=display:flex><span>  __attribute__((format(printf, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>)));
</span></span></code></pre></div><p>Objective-C 程序员还可以使用 <code>__NSString__</code> 来应用跟 <code>NSString +stringWithFormat:</code> 和 <code>NSLog()</code> 一样的格式化字符串规则。</p><h3 id=nonnull><code>nonnull</code></h3><blockquote><p><code>nonnull</code> 属性表明一些函数参数应该是非空的指针。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>my_memcpy</span> (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dest, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>src, size_t len)
</span></span><span style=display:flex><span>  __attribute__((nonnull (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>)));
</span></span></code></pre></div><p>使用 <code>nonnull</code> 把对于值的预期进行了显式的硬编码，可以帮助我们找到所有调用函数时可能潜伏的 <code>NULL</code> 指针 bug。记住一点，编译期错误 ≫ 运行时错误。</p><h3 id=noreturn><code>noreturn</code></h3><blockquote><p>少数的几个标准库函数，例如 <code>abort</code> 和 <code>exit</code>，是不能返回的。GCC 了解这一点。<code>noreturn</code> 这个属性用于声明其他不能返回的函数。</p></blockquote><p>举个例子，AFNetworking <a href=https://github.com/AFNetworking/AFNetworking/blob/1.1.0/AFNetworking/AFURLConnectionOperation.m#L157>在网络请求线程的入口方法出使用了 <code>noreturn</code> 属性</a>。这个方法用于产生专门用于网络请求的 <code>NSThread</code>，确保这个线程在应用整个生命周期内都能一直运行。</p><h3 id=pure--const><code>pure</code> / <code>const</code></h3><blockquote><p><code>pure</code> 属性表明这个函数除了返回值以外没有任何副作用，也就是说它们的返回值只依赖于传入的参数和/或全局变量。这种函数可以通过常见的子表达式消除和循环优化技术进行优化，就像算术操作符一样。</p></blockquote><blockquote><p><code>const</code> 属性表明这个函数除了参数之外不会对值进行检查，除了返回值之外也没有其他副作用。注意，一个有指针类型的参数同时检查指针指向的数据的函数，一定不要声明为 <code>const</code>。同样的，一个调用在内部非 <code>const</code> 函数的函数通常也不能是 <code>const</code>。<code>const</code> 函数返回 <code>void</code> 类型是没有意义的。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>square</span>(<span style=color:#66d9ef>int</span> n) __attribute__((<span style=color:#66d9ef>const</span>));
</span></span></code></pre></div><p><code>pure</code> 和 <code>const</code> 都是为了支持高效的性能优化而营造出函数式编程范例的属性。<code>const</code> 可以被看做是更加严格的 <code>pure</code>，因为它不依赖于全局变量或者指针。</p><p>举个例子，因为被声明为 <code>const</code> 的函数结果除了传入参数之外不依赖于任何东西，这个函数的结果就可以被缓存起来，当之后用同样的参数调用的时候可以直接把缓存返回（就像我们知道一个数字的平方是另一个常数，所以我们只需要计算一次就可以了）。</p><h3 id=unused><code>unused</code></h3><blockquote><p>当一个函数增加了这个属性声明的时候，意味着它可能不会被使用，GCC 不会对这个函数产生警告。</p></blockquote><p>使用 <code>__unused</code> 关键字可以达到同样的效果，可以在方法实现中声明没有被使用的参数。通过了解这个上下文，编译器可以进行相应的优化。你更可能会在 delegate 的方法实现里使用 <code>__unused</code>，因为 protocols 为了支持更多可能的用例经常会提供必要的参数之外的上下文。</p><h2 id=llvm>LLVM</h2><p>和其他 GCC 特性一样，Clang 支持了 <code>__attribute__</code>， 还加入了一小部分扩展特性。</p><p>要检查能否使用特定的属性，可以用 <code>__has_attribute</code> 这个指令。</p><h3 id=availability><code>availability</code></h3><blockquote><p>Clang 引入了可用性属性，可以放在声明之后，表明这个声明在操作系统版本层次上的生命周期。考虑下面这个虚构的函数 f 的声明：</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>void</span>) __attribute__((availability(macosx,introduced<span style=color:#f92672>=</span><span style=color:#ae81ff>10.4</span>,deprecated<span style=color:#f92672>=</span><span style=color:#ae81ff>10.6</span>,obsoleted<span style=color:#f92672>=</span><span style=color:#ae81ff>10.7</span>)));
</span></span></code></pre></div><blockquote><p><code>availability</code> 属性指出 <code>f</code> 在 OS X Tiger 中被引入，在 OS X Snow Leopard 中被废弃，在 OS X Lion 中被淘汰。</p></blockquote><blockquote><p>Clang 使用这些信息来判断使用 <code>f</code> 是不是安全的：举个例子，如果 Clang 需要为 OS X Leopard 编译代码，调用 f() 没有问题。如果 Clang 为 OS X Snow Leopard 编译代码，调用仍然会成功，不过 Clang 会发出警告，表明这个函数已经废弃了。最后，如果 Clang 为 OS X Lion 平台编译代码，调用会失败，因为 <code>f()</code> 已经不可用了。</p></blockquote><blockquote><p><code>availability</code> 属性是用一个逗号分隔的列表，列表的第一项是平台名称，然后是指出声明的生命周期当中重要的里程碑时间（如果有的话）的语句，最后是额外的信息。</p></blockquote><ul><li><code>introduced</code>: 声明被引入的第一个版本。</li><li><code>deprecated</code>: 声明被废弃的第一个版本，意味着用户应当从这个 API 迁移到另外的方法。</li><li><code>obsoleted</code>: 声明被废弃的第一个版本，意味着它被彻底删除不能使用了。</li><li><code>unavailable</code>: 声明在这个平台上从来就是不可用的</li><li><code>message</code>: 额外的文本信息，Clang 在对于废弃和淘汰声明给出警告或者错误的时候会提供这些信息，可以用于指导用户进行 API 替换。</li></ul><blockquote><p>在同一个声明上可以添加多个可用性属性，它们可能是针对不同平台的。只有当前和目标平台对应的平台可用性属性会发挥作用，其他的属性会被忽略掉。如果没有和当前目标苹果对应的可用性属性，整个可用性属性会被忽略。</p></blockquote><p>支持的平台：</p><ul><li><code>ios</code>: 苹果 iOS 操作系统。最低的部署目标通过 <code>-mios-version-min=*version*</code> 或者 <code>-miphoneos-version-min=*version*</code> 命令行参数指定。</li><li><code>macosx</code>: 苹果 OS X 操作系统。最低的部署目标通过 <code>-mmacosx-version-min=*version*</code> 命令行参数指定。</li></ul><h3 id=overloadable><code>overloadable</code></h3><blockquote><p>Clang 在 C 语言中提供了 C++ 函数重载支持，通过 <code>overloadable</code> 这个属性实现。例如我们要提供多个不同重载版本的 <code>tgsin</code> 函数，它会调用合适的标准库函数，分别提供对 <code>float</code>，<code>double</code> 和 <code>long double</code> 精度的值计算 <code>sine</code> 值。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;math.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>__attribute__</span>((overloadable)) tgsin(<span style=color:#66d9ef>float</span> x) { <span style=color:#66d9ef>return</span> sinf(x); }
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>__attribute__</span>((overloadable)) tgsin(<span style=color:#66d9ef>double</span> x) { <span style=color:#66d9ef>return</span> sin(x); }
</span></span><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>__attribute__</span>((overloadable)) tgsin(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>double</span> x) { <span style=color:#66d9ef>return</span> sinl(x); }
</span></span></code></pre></div><p>注意 <code>overloadable</code>只能用于函数。你可以通过使用 <code>id</code> 和 <code>void *</code> 这种泛型的返回值和参数类型，在一定程度上实现方法声明的重载。</p><hr><p>对于编译器优化来说，上下文至关重要。通过给编译器对代码的解析添加约束，生成的代码更有可能达到最高的效率。对你的编译器做些让步，结果总是好的。</p><p>同时 <code>__attribute__</code> 也不仅仅是为了编译器而添加的：下一个看到这段代码的人也会感激额外的这部分工作的。因此多付出一些吧，为了和你共事的同事，为了下一个接手代码的人，也为了两年之后（已经彻底忘了这段代码是什么意思）的你。</p><p>因为最终，你收获的与你付出的总是相等的（译者注：原文 the love you take is equal to the love you make，源自 Beatles 的作品 The End）。</p><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2013-01-14 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mattt 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Objective-C target=_blank>Objective-C</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>