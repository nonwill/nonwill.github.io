<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>Core Location in iOS 8</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="Core Location in iOS 8,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="Core Location in iOS 8,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>Core Location in iOS 8</span><span class=btRight><span title="Author · 作者" class=author>Mike Lazer-Walker</span> <span title="Translator · 翻译" class=author>April Peng</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p>自从 iPhone 存在以来，位置服务就一直处于非常重要的位置。Maps.app 是第一代 iPhone 里杀手锏的功能之一。Core Location API 也在 iPhone OS SDK 最初的公开版本里就存在了。每一次发布 iOS，Apple 都会给这个库逐步添加新功能，比如后台运行的位置服务，坐标化，以及室内定位（ iBeacons ）。</p><p>iOS 8 仍然继续坚定的延续着这个进程。跟其他最新的更新类似，Core Location 被改动了不少，不管是允许开发者做之前并不被允许的开发，还是帮助维护用户隐私。更特别的是，iOS 8 给 Core Location 带来了三个主要的改进：更分化的权限，室内定位以及访问监控。</p><h2 id=权限>权限</h2><p>一个 app 总有各种各样的理由需要得到你的位置信息。一个能够提示你每个转弯在哪里的 GPS 应用就需要持续获得你的位置信息，才可以在转弯的时候提示你。一个餐厅推荐的 app 也需要得到你的位置信息（即便它并没有打开的情况下），才可以在你到你朋友点赞的餐厅附近的时候能收到推送消息。一个 Twitter 应用在发推的时候也可能需要你的位置，但在你不使用的时候不应该监控你的位置。</p><p>在 iOS 8 之前，位置服务的权限是二元的：你要么赋予一个应用得到使用位置服务的权限，要么不给。你可以在 Settings.app 查看哪些 app 可以在后台取得你的位置信息，但除了完全不让这个 app 使用位置服务之外，你不能做任何的事来阻止它获取位置信息。</p><p>iOS 8 修改了这个问题，它把位置服务权限拆分成了 2 个不同的授权。</p><ul><li><p>“使用期间” 的授权会只允许应用在 - 就跟你猜测的一样 - 使用期间取得你的位置信息。</p></li><li><p>“始终” 的授权则跟之前版本的 iOS 那样，会给应用后台权限。</p></li></ul><p>这是对用户隐私的一个重大改进，但对于我们开发者来说则意味着多一些的工作。</p><h3 id=取得权限>取得权限</h3><p>在早前的 iOS 版本中，获取位置服务权限是隐式的。比如 <code>CLLocationManager</code>，如果应用程序还没有被许可或者之前被拒绝了的话，下面的代码会触发系统弹出提示框向用户获取位置服务的授权：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>Foundation</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>CoreLocation</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> manager = CLLocationManager()
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> CLLocationManager.locationServicesEnabled() {
</span></span><span style=display:flex><span>    manager.startUpdatingLocation()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>把事情简化一下，假定我们声明了一个 <code>manager</code> 实例作为所有例子的成员变量，它的 delegate 是它的 owner。</p></blockquote><p>让 <code>CLLocationManager</code> 取得最新的位置的这个操作会让系统弹出是否允许位置服务的提示。</p><p>在 iOS 8，取得权限和使用位置服务已经分成两个动作了。分别用两个不同的方法取得权限：<code>requestWhenInUseAuthorization</code> 和 <code>requestAlwaysAuthorization</code>。前者只能让应用在使用的时候有权获取位置数据；后者会得到跟之前 iOS 一样的后台位置服务。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>if</span> CLLocationManager.authorizationStatus() == .NotDetermined {
</span></span><span style=display:flex><span>    manager.requestAlwaysAuthorization()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>或者</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>if</span> CLLocationManager.authorizationStatus() == .NotDetermined {
</span></span><span style=display:flex><span>    manager.requestWhenInUseAuthorization()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因为这是异步的，应用不能立即开始使用位置服务。取而代之的是，应用必须实现 <code>locationManager:didChangeAuthorizationStatus</code> 的 delegate 方法，这个方法会在用户改变权限状态的时候调用。</p><p>如果用户之前已经授权了位置服务，那么在每次位置管理器被初始化，并且 delegate 被设置了相应的权限状态的情况下这个代理方法仍然会被调用。这使得一个单一的代码路径使用定位服务更为方便。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>locationManager</span>(manager: CLLocationManager!,
</span></span><span style=display:flex><span>                     didChangeAuthorizationStatus status: CLAuthorizationStatus)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> status == .AuthorizedAlways <span style=color:#f92672>||</span> status == .AuthorizedWhenInUse {
</span></span><span style=display:flex><span>        manager.startUpdatingLocation()
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=描述字符串>描述字符串</h3><p>想在 iOS 8 中使用定位，另一个改变是必须的。在这之前，应用可以选择性的在 <code>Info.plist</code> 中包含 &lsquo;NSLocationUsageDescription&rsquo; 的关键字。这个值是一个纯文本的字符串，向用户说明了应用预期要使用位置服务。现在这个值被拆分成了两个不同的关键字（<code>NSLocationWhenInUseUsageDescription</code> 和 <code>NSLocationAlwaysUsageDescription</code>），而且是必填的；如果你不添加对应的关键字就去调用 <code>requestWhenInUseAuthorization</code> 或 <code>requestAlwaysAuthorization</code>，那么将不会有任何的弹出提示给用户。</p><p><img alt="Core Location Always Authorization" src=/media/NSHipster/core-location-always-authorization.png></p><p><img alt="Core Location When In Use Authorization" src=/media/NSHipster/core-location-when-in-use-authorization.png></p><h3 id=获取多个权限>获取多个权限</h3><p>另一个值得注意的细节是授权的弹出框会只显示一次。在 <code>CLLocationManager.authorizationStatus()</code> 返回除 <code>NotDetermined</code> 之外的值之后，不管调用 <code>requestWhenInUseAuthorization()</code> 或 <code>requestAlwaysAuthorization()</code> 都不会有一个 <code>UIAlertController</code> 显示出来了。在用户最初的选择之后，唯一改变授权的方式是到 Settings.app 或者到隐私设置，又或者是应用自己的设置页面。</p><p>旧的授权机制各种不方便的情况下，现在让应用在它的生存周期内询问不论是“使用期间”还是“始终”的权限的机制明显复杂多了，更不方便了。为了缓解这一点，Apple 引入了一个字符串常量，<code>UIApplicationOpenSettingsURLString</code>，它存储了一个 URL 用来打开当前应用在 Settings.app 对应的页面。</p><p>下面的例子显示了如何在应用里弹出两种类型的权限获取窗口，如果你的应用打算获取始终的权限的话，可以参考一下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>switch</span> CLLocationManager.authorizationStatus() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> .Authorized:
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> .NotDetermined:
</span></span><span style=display:flex><span>        manager.requestWhenAlwaysAuthorization()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> .AuthorizedWhenInUse, .Restricted, .Denied:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> alertController = UIAlertController(
</span></span><span style=display:flex><span>            title: <span style=color:#e6db74>&#34;Background Location Access Disabled&#34;</span>,
</span></span><span style=display:flex><span>            message: <span style=color:#e6db74>&#34;In order to be notified about adorable kittens near you, please open this app&#39;s settings and set location access to &#39;Always&#39;.&#34;</span>,
</span></span><span style=display:flex><span>            preferredStyle: .Alert)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> cancelAction = UIAlertAction(title: <span style=color:#e6db74>&#34;Cancel&#34;</span>, style: .Cancel, handler: <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>        alertController.addAction(cancelAction)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> openAction = UIAlertAction(title: <span style=color:#e6db74>&#34;Open Settings&#34;</span>, style: .Default) { (action) <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> url = NSURL(string:UIApplicationOpenSettingsURLString) {
</span></span><span style=display:flex><span>                UIApplication.sharedApplication().openURL(url)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        alertController.addAction(openAction)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>.presentViewController(alertController, animated: <span style=color:#66d9ef>true</span>, completion: <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img alt="Core Location Settings Alert" src=/media/NSHipster/core-location-settings-alert.png></p><p><img alt="Core Location Settings Location Never" src=/media/NSHipster/core-location-settings-1.png></p><p><img alt="Core Location Settings Location Always" src=/media/NSHipster/core-location-settings-2.png></p><h3 id=向后兼容>向后兼容</h3><p>所有这些新的 API 都只支持 iOS 8。对于要支持 iOS 7 或之前 iOS 版本的应用，则必须维护两部分代码，一个是为 iOS 8 获取权限的，同时还需要维护之前的获取位置更新的方法。一个简单的实现会看上去像下面这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>triggerLocationServices</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> CLLocationManager.locationServicesEnabled() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>self</span>.manager.respondsToSelector(<span style=color:#e6db74>&#34;requestWhenInUseAuthorization&#34;</span>) {
</span></span><span style=display:flex><span>            manager.requestWhenInUseAuthorization()
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            startUpdatingLocation()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>startUpdatingLocation</span>() {
</span></span><span style=display:flex><span>    manager.startUpdatingLocation()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// </span><span style=color:#75715e>MARK:</span><span style=color:#75715e> - CLLocationManagerDelegate</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>locationManager</span>(manager: CLLocationManager!, didChangeAuthorizationStatus status: CLAuthorizationStatus) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> status == .AuthorizedWhenInUse <span style=color:#f92672>||</span> status == .Authorized {
</span></span><span style=display:flex><span>        startUpdatingLocation()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=建立用户的信任>建立用户的信任</h3><p>现在在 iOS 8 上有一个共同的变化趋势是：它们更容易得到用户的信任。</p><p>显式的请求的授权，鼓励应用程序在用户试图做一些事情之前不请求授权。这包括了用使用说明来很清晰的解释为什么你需要的访问位置信息，以及应用程序将如何使用它。“使用期间” 和 “始终” 的区别授权，使用户感到轻松，因为应用只得到了需要的数据。</p><p>当然，这些新的 API 并不能阻止应用做跟之前一样的事。所有应用 “需要” 针对支持 iOS 8 的事只是添加对 <code>useAlwaysAuthorization</code> 的调用，以及添加一个全局适用的字符串。但随着这些新的变化， Apple 正在传达一个重要的信息，那就是你应该尊重你的用户。一旦用户习惯了像这样尊重用户隐私的应用程序，不难想象的是，不负责任地使用定位服务 的应用会在 App Store 得到更多负面的评分。</p><h2 id=室内定位追踪>室内定位追踪</h2><p>如果一个人仔细阅读了 <code>CoreLocation.framework</code> 的 API 改动文件，会发现最令人费解的改动之一是引进了 <code>CLFloor</code>，一个新的只有相当简单的接口对象：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CLFloor</span> : NSObject {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> level: Int { <span style=color:#66d9ef>get</span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>CLFLoor</span> : <span style=color:#a6e22e>NSObject</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@property</span>(<span style=color:#66d9ef>readonly</span>, <span style=color:#66d9ef>nonatomic</span>) NSInteger level
</span></span><span style=display:flex><span><span style=color:#66d9ef>@end</span>
</span></span></code></pre></div><p>就是这样。仅一个属性，一个整形值来表示当前位置处于建筑物的第几层楼。</p><blockquote><p>欧洲人肯定会很高兴的发现一楼是用 &lsquo;1&rsquo; 表示的, 而不是 &lsquo;0&rsquo;。</p></blockquote><p>由 <code>CLLocationManager</code> 返回的 <code>CLLocation</code> 对象可能包括一个 <code>floor</code> 属性，但如果你是写一个使用定位服务的示例应用程序，你会发现 <code>CLLocation</code> 对象的 <code>floor</code> 属性总是 <code>nil</code>。</p><p>这是因为该API的变化只是 iOS8 中引入的室内定位跟踪这个大功能的冰山一角。对于大型空间的应用开发，例如艺术博物馆或百货公司这种， Apple 现在已经有结合了无线，GPS，蜂窝，和 室内定位数据的内置 Core Location API 支持 <abbr title="Indoor Positioning Systems">IPS</abbr> 。</p><p>也就是说，这个新功能的信息令人吃惊的来之不易。该项目目前被很好的严格限制访问了，仅允许已通过从 <a href=https://mapsconnect.apple.com>Apple Maps Connect</a> 申请的程序。关于该项目的的有限信息是在<a href=http://asciiwwdc.com/2014/sessions/708>今年的WWDC(Session 708: Taking Core Location Indoors)</a>被初露头角的，但大部分的后台细节都被隐藏在被关上的门之后了。对于大多数的我们来说，别无选择的，只能打消没有用的好奇心。</p><h2 id=clvisit>CLVisit</h2><p>很多应用程序，使用位置监控的原因是确定用户是否在某个确定的地方。概念上讲，你在想的是诸如“地方”或“访问”的名词术语，而不是原始的 GPS 坐标。</p><p>然而，除非你可以得益于使用区域监视（被限制在一个相对小的数量的区域）或室内定位（ iBeacon ）测距（这要求把室内定位硬件真正安装在一个空间内），否则用 Core Location 的后台监控工具并不是非常适合。开发一个登记应用或像 <a href=https://moves-app.com>Moves</a> 这样的全面的日志应用，位置监控和花费很多时间做特定处理一般意味着消耗大量的电量。</p><p>在 iOS 8 里， Apple 曾试图通过引进 <code>CLVisit</code> 来解决这个问题， 这是一种新型的后台位置的监控。一个 <code>CLVisit</code> 表示该用户已经处于某个位置的时间长度，包括一个坐标和开始/结束的时间戳。</p><p>理论上讲，使用访问监控并不比任何其他后台定位跟踪做更多的事。简单地调用 <code>manager.startMonitoringVisits()</code> 将启用后台访问跟踪，假设用户同意授权你的应用程序“始终”的使用权限。一旦启动，你的应用程序将在有位置更新的时候在后台被唤醒，不像基本的定位监控，如果系统有个访问更新的队列（通常可以使更新延迟），你的 delegate 方法将被调用多次，每个单一的访问调用一次，而不是一个包含 CLLocation 对象的数组调用 <code>locationManager:didReceiveUpdates:</code>。调用 <code>manager.stopMonitoringVisits()</code> 会停止跟踪。</p><h3 id=处理访问>处理访问</h3><p>每个 <code>CLVisit</code> 对象包含了一些基本属性：平均坐标，水平精度和到达日期和离开时间。</p><p>每次一个访问被追踪到，<code>CLLocationManagerDelegate</code> 可能会被告知两次：一次是在用户刚抵达一个新的地方的时候，以及当用户离开的时候。你可以通过检查 <code>departureDate</code> 属性来分辨它们; <code>NSDate.distantFuture()</code> 的离开时间意味着用户还在那儿。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>locationManager</span>(manager: CLLocationManager!, didVisit visit: CLVisit!) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> visit.departureDate.isEqualToDate(NSDate.distantFuture()) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// User has arrived, but not left, the location</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The visit is complete</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=实现须知>实现须知</h3><p>至少到 iOS 8.1，CLVisit 还不是那么精确。开始和结束时间一般有一两分钟的误差，是否访问某个地方的线路边际有点模糊。在咖啡店的角落躲一分钟可能不会触发访问，但在等一个特别长的红绿灯的时候却有可能触发。很可能 Apple 将在操作系统的后续升级的时候提升访问检测的质量，但现在如果你的应用程序对访问检测的精度要求很高的话，你最好不要依赖 <code>CLVisit</code>。</p><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2014-11-10 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mike Lazer-Walker 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Cocoa target=_blank>Cocoa</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>