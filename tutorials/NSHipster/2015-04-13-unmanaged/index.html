<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>Unmanaged</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="Unmanaged,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="Unmanaged,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>Unmanaged</span><span class=btRight><span title="Author · 作者" class=author>Nate Cook</span> <span title="Translator · 翻译" class=author>Croath Liu</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p>API 对于开发者来说不只是把功能点接口暴露出来而已，同时也传达给我们一些其他的信息，比如说接口如何以及为什么要使用某些值。因为要传达这些信息，给东西起适当的名字这件事才变成了计算机科学中最难的部分之一，而这也成为好的 API 和不好的 API 的重要区别。</p><p>通过 Swift 标准库就可以看出，Swift 在安全性和可靠性方面和与 Objective-C 互通性之间方面有着明显的界线。像 <code>Int</code>、<code>String</code> 和 <code>Array</code> 这些类型在使用过程中都会表现出直接且无歧义的行为，但如果什么都不考虑就创建 <code>UnsafeMutablePointer</code> 或 <code>Unmanaged</code> 等类型的实例，那恐怕就要踩到坑里了。</p><p>这次我们关注 <code>Unmanaged</code> 这个关键字。<code>Unmanaged</code> 表示对不清晰的内存管理对象的封装，以及用烫手山芋的方式来管理他们。但开始之前，我们先回顾一下历史。</p><h2 id=自动引用计数automatic-reference-counting>自动引用计数（Automatic Reference Counting）</h2><p>在石器时代（我是说 2011 年），在 Objective-C 中还要手动进行引用计数。每一个 retain 操作的引用都要与一个相应的 release 操作构成一个平衡的组合，才能避免应用在场景切换的过程中产生僵尸引用和内存泄漏&mldr;&mldr;好脏。对于工程师来说需要小心地计算每一个对象的引用计数实在是太累了，而且对于新入行者门槛也过高了。</p><p>自动引用计数（ARC）的到来让和手动内存管理相关的一切都失去了必要。在 ARC 下，编译器会在每一个生命周期内按照规则帮你进行 <code>retain</code>/<code>release</code>/<code>autorelease</code> 指令的调用，减少了很多麻烦。<a href=https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html>这幅图</a> 绝对会让你感受到抛弃手动内存管理的益处：</p><p><img alt="ARC 出现前后内存管理差异" src=/media/NSHipster/unmanaged-arc.png></p><p>在现在这个后 ARC 的世界里，所有的 Objective-C 和 从 Objective-C 方法返回的 Core Foundation 类型的内存都被自动管理，只剩下由 C 函数返回的 Core Foundation 类型还没有收编。对于后者而言，对象所有权的管理仍然停留在调用 <code>CFRetain()</code> 和 <code>CFRelease()</code>、或通过某个 <code>__bridge</code> 函数桥接到 Objective-C 对象的方式的层面上。</p><p>为了帮助大家理解 C 函数返回对象是否被调用者持有，苹果使用了 <em>Create 规则</em> 和 <em>Get 规则</em> 命名法：</p><ul><li><p><strong>Create 规则</strong> 的意思是，如果一个函数的名字含有 <code>Create</code> 或 <code>Copy</code> ，函数的返回值被函数的调用者持有。也就是说，调用 <code>Create</code> 或 <code>Copy</code> 函数的对象应该对返回对象调用 <code>CFRelease</code> 进行释放。</p></li><li><p><strong>Get 规则</strong> 则不像 Create 规则一样能从命名规则看出规律。或许可以描述成函数名不含有 <code>Create</code> 或 <code>Copy</code> 的函数？这种函数遵守 Get 规则，返回对象的持有者不会发生变化。如果想持久化一个返回对象，大多数时候就是你自己手动 retain 它。</p></li></ul><blockquote><p>如果你是一个像我一样系三条皮带都怕裤子掉下来的那种开发者，那就去好好看看文档。即使大多数 API 遵从这种命名规则，以防意外情况，用的时候都应该好好看看文档确认一下。</p></blockquote><p>等等！等等！我们这篇文章是讨论 <em>Swift</em> 的，回到正轨！</p><p>Swift 仅支持 ARC，所以也没有地方调用 <code>CFRelease</code> 或 <code>__bridge_retained</code>。那么 Swift 是如何让这种 “在上下文中内存管理” 的哲学融入自己的内存安全体系呢？</p><p>事情分两种情况。<em>注明</em> 的 API，Swift 能够在上下文中严格遵循注释描述对 CoreFoundation API 进行内存管理，并以同样内存安全的方式桥接到 Objective-C 或 Swift 类型上。对于没有明确注明的 API，Swift 则会通过 <code>Unmanaged</code> 类型把工作交给开发者。</p><h2 id=管理-unmanaged>管理 <code>Unmanaged</code></h2><p>虽然大多数的 CoreFoundation API 都有注明是否可自动管理，但一些重要的部分还没有得到充分重视。这篇文章编写时，Address Book framework 的 API 似乎是比较重要的尚未注明的部分，有一些函数还要传入或返回 <code>Unmanaged</code> 类型的对象。</p><p>一个 <code>Unmanaged&lt;T></code> 实例封装有一个 CoreFoundation 类型 <code>T</code>，它在相应范围内持有对该 <code>T</code> 对象的引用。从一个 <code>Unmanaged</code> 实例中获取一个 Swift 值的方法有两种：</p><blockquote><ul><li><code>takeRetainedValue()</code>：返回该实例中 Swift 管理的引用，并在调用的同时减少一次引用次数，所以可以按照 Create 规则来对待其返回值。</li></ul></blockquote><blockquote><ul><li><code>takeUnretainedValue()</code>：返回该实例中 Swift 管理的引用而 <em>不减少</em> 引用次数，所以可以按照 Get 规则来对待其返回值。</li></ul></blockquote><p>在实践中最好不要直接操作 <code>Unmanaged</code> 实例，而是用这两个 <code>take</code> 开头的方法从返回值中拿到绑定的对象。</p><p>我们来看一个例子。比如说我们这里要创建一个 <code>ABAddressBook</code> 来获取用户最好的朋友的名字：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> bestFriendID = ABRecordID(...)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Create Rule - retained</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> addressBook: ABAddressBook = ABAddressBookCreateWithOptions(<span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>).takeRetainedValue()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Get Rule - unretained</span>
</span></span><span style=display:flex><span>    bestFriendRecord: ABRecord = ABAddressBookGetPersonWithRecordID(addressBook, bestFriendID)?.takeUnretainedValue(),
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create Rule (Copy) - retained</span>
</span></span><span style=display:flex><span>    name = ABRecordCopyCompositeName(bestFriendRecord)?.takeRetainedValue() <span style=color:#66d9ef>as</span>? String
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    println(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\(</span>name<span style=color:#e6db74>)</span><span style=color:#e6db74>: BFF!&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Rhonda Shorsheimer: BFF!</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过使用 Swift 1.2 新增的 optional 绑定，取得对象并将其转化为 Swift 类型简直是小菜一碟。</p><h2 id=最好的解决问题的方法是避免遇到问题>最好的解决问题的方法是避免遇到问题</h2><p>现在我们已经知道如何对付 <code>Unmanaged</code> 了，现在我们还是看看如何避免碰到这种情况吧。如果 <code>Unmanaged</code> 引用是从你自己写的 C 函数返回的，那么你最好还是注明一下。这种注释能够帮助编译器理解如何自动管理你所返回对象的内存：就不要用 <code>Unmanaged&lt;CFString></code> 了，直接返回一个在 Swift 中类型安全以及内存管理完善的 <code>CFString</code> 类型。</p><p>举例说明，我们有一个函数能将两个 <code>CFString</code> 对象拼装成一个字符串，并且要告诉 Swift 这个返回字符串的内存是被如何管理的。根据上面提到的命名规则，我们的函数应该叫做 <code>CreateJoinedString</code> —— 这个名字表达的意思是调用者将持有返回值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>CFStringRef <span style=color:#a6e22e>CreateJoinedString</span>(CFStringRef string1, CFStringRef string2);
</span></span></code></pre></div><p>既然这样，在函数实现中我们用 <code>CFStringCreateMutableCopy</code> 创建的 <code>resultString</code> 返回时没有与其创建函数平衡的 <code>CFRelease</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>CFStringRef <span style=color:#a6e22e>CreateJoinedString</span>(CFStringRef string1, CFStringRef string2) {
</span></span><span style=display:flex><span>    CFMutableStringRef resultString <span style=color:#f92672>=</span> <span style=color:#a6e22e>CFStringCreateMutableCopy</span>(NULL, <span style=color:#ae81ff>0</span>, string1);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CFStringAppend</span>(resultString, string2);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> resultString;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 Swift 中像上面一样，我们也要手动管理内存。我们的函数被引用成返回一个 <code>Unmanaged&lt;CFString>!</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// imported declaration:</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>CreateJoinedString</span>(string1: CFString!, string2: CFString!) -&gt; Unmanaged&lt;CFString&gt;<span style=color:#f92672>!</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// to call:</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> joinedString = CreateJoinedString(<span style=color:#e6db74>&#34;First&#34;</span>, <span style=color:#e6db74>&#34;Second&#34;</span>).takeRetainedValue() <span style=color:#66d9ef>as</span> String
</span></span></code></pre></div><p>既然我们的函数遵循了 Create 规则进行命名，那么就可以打开编译器的隐式桥接来消除 <code>Unmanaged</code> 歧义。Core Foundation 提供了两个宏：<code>CF_IMPLICIT_BRIDGING_ENABLED</code> 和 <code>CF_IMPLICIT_BRIDGING_DISABLED</code> —— 用来打开和关闭 Clang 的 <code>arc_cf_code_audited</code> 变量：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>CF_IMPLICIT_BRIDGING_ENABLED            <span style=color:#75715e>// get rid of Unmanaged
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#pragma clang assume_nonnull begin      </span><span style=color:#75715e>// also get rid of !s
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>CFStringRef <span style=color:#a6e22e>CreateJoinedString</span>(CFStringRef string1, CFStringRef string2);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma clang assume_nonnull end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>CF_IMPLICIT_BRIDGING_DISABLED
</span></span></code></pre></div><p>现在 Swift 已经能够控制这个函数返回值的内存管理了，我们的代码里也可以不用 <code>Unmanaged</code> 了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// imported declaration:</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>CreateJoinedString</span>(string1: CFString, string2: CFString) -&gt; CFString
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// to call:</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> joinedString = CreateJoinedString(<span style=color:#e6db74>&#34;First&#34;</span>, <span style=color:#e6db74>&#34;Second&#34;</span>) <span style=color:#66d9ef>as</span> String
</span></span></code></pre></div><p>最后一点，如果你的函数 <em>没有使用</em> Create/Get 规则来命名，那么明显地，你把这些函数用这个法则重新命名一次。当然在真实情况下这种修改可能并不容易，但是拥有明确性一致性返回的 API 的好处不仅仅是避免 <code>Unmanaged</code>。如果不能够重命名，也有另外两种注明方式可以使用：将持有者转移到调用者的函数应该使用 <code>CF_RETURNS_RETAINED</code>，反之则使用 <code>CF_RETURNS_NOT_RETAINED</code>。比如说，这个命名糟糕的 <code>MakeJoinedString</code> 就是用了手动注明的方式来表明其性质：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>CF_RETURNS_RETAINED
</span></span><span style=display:flex><span>__nonnull CFStringRef <span style=color:#a6e22e>MakeJoinedString</span>(__nonnull CFStringRef string1,
</span></span><span style=display:flex><span>                                       __nonnull CFStringRef string2);
</span></span></code></pre></div><hr><p>你可能感觉 <code>Unmanaged</code> 只是一时的权宜之计 —— 是的确实，因为对 CoreFoundation 中数量庞大的 API 进行标注的工作还在进行中。随着函数的交互形式被修改得越来越清晰，每一代 Xcode 发布都有可能需要你减少对 <code>takeRetainedValue()</code> 的调用。在最后一个 <code>CFUnannotatedFunctionRef</code> 被改好之前，<code>Unmanaged</code> 将会帮助你渡过难关。</p><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2015-04-13 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Nate Cook 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Swift target=_blank>Swift</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>