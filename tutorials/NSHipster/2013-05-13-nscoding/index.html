<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>NSCoding / NSKeyedArchiver</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="NSCoding / NSKeyedArchiver,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="NSCoding / NSKeyedArchiver,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>NSCoding / NSKeyedArchiver</span><span class=btRight><span title="Author · 作者" class=author>Mattt</span> <span title="Translator · 翻译" class=author>Yu Jin</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p>在构建应用程序时，一个重要的架构决策问题是在每次启动之间如何持久化数据。问题是如何精准的重现最后一次关闭应用前的状态；如何描述对象图以使下次完美地重新构建。</p><p>在 iOS 和 OS X 上， 苹果提供了两种选择 ：<a href=https://developer.apple.com/library/mac/#documentation/cocoa/Conceptual/CoreData/cdProgrammingGuide.html>Core Data</a> 或 <a href=https://developer.apple.com/library/ios/#Documentation/Cocoa/Reference/Foundation/Classes/NSKeyedArchiver_Class/Reference/Reference.html><code>NSKeyedArchiver</code></a> / <a href=https://developer.apple.com/library/ios/#documentation/Cocoa/Reference/Foundation/Classes/NSKeyedUnarchiver_Class/Reference/Reference.html><code>NSKeyedUnarchiver</code></a> （用来将遵循 <code>&lt;NSCoding></code> 的类序列化）</p><blockquote><p>或者更确切地说：有三种选择，如果你算上<code>NSURLCache</code>的话. 在client-server应用场景下，在每次启动时加载必要的数据是一种可行的设计，尤其是结合磁盘缓存，存储服务器的响应，这样当发送对应请求的时候可以立即返回。在实践中，网络层和对象层上的缓存结合是可取的。</p></blockquote><p>当涉及到建模，查询，遍历，持久化复杂的对象图，那Core Data是无可代替的。Core Data 是把大锤子，但不是所有的问题都是足够大的钉子。</p><p>Core Data 和 <code>NSKeyedArchiver</code>客观和常见的比较可能是这样的：</p><table id=figure-1 class=core-data-versus-nskeyedarchiver><thead><tr><th></th><th>Core Data</th><th>NSKeyedArchiver</th></tr></thead><tbody><tr><td>Entity Modeling</td><td>Yes</td><td>No</td></tr><tr><td>Querying</td><td>Yes</td><td>No</td></tr><tr><td>Speed</td><td>Fast</td><td>Slow</td></tr><tr><td>Serialization Format</td><td>SQLite, XML, or NSData</td><td>NSData</td></tr><tr><td>Migrations</td><td>Automatic</td><td>Manual</td></tr><tr><td>Undo Manager</td><td>Automatic</td><td>Manual</td></tr></tbody></table><p>等等。在这场对决中，没有什么可比性，它看起来是一边倒的局势。</p><p>&mldr;也就是说，直到你从一个稍微不同的角度看它：</p><table id=figure-2 class=core-data-versus-nskeyedarchiver><thead><tr><th></th><th>Core Data</th><th>NSKeyedArchiver</th></tr></thead><tbody><tr><td>Persists State</td><td>Yes</td><td>Yes</td></tr><tr><td>Pain in the Ass</td><td>Yes</td><td>No</td></tr></tbody></table><p>通过这些对比，在某些情况下<code>NSKeyedArchiver</code>是一个完全合理的选择。并非所有的应用程序需要查询的数据。并非所有的应用程序需要自动迁移。并非所有的应用程序处理大型或复杂的对象图。而且应用中确实是有一些模块更好地被一个简单的方案解决。</p><p>这篇文章将关注如何，何时，为什么选择<code>NSKeyedArchiver</code> 和 <code>NSCoding</code>。希望能提供给亲爱的读者们以启发选择最合适的工具。</p><hr><p><code>NSCoding</code> 是一个简单的协议，有两个方法： <code>-initWithCoder:</code> 和 <code>encodeWithCoder:</code>。遵循<code>NSCoding</code>协议的类可以被序列化和反序列化，这样可以归档到磁盘上或分发到网络上。</p><p>举个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>Book</span> : <span style=color:#a6e22e>NSObject</span> <span style=color:#f92672>&lt;</span>NSCoding<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@property</span> NSString <span style=color:#f92672>*</span>title;
</span></span><span style=display:flex><span><span style=color:#66d9ef>@property</span> NSString <span style=color:#f92672>*</span>author;
</span></span><span style=display:flex><span><span style=color:#66d9ef>@property</span> NSUInteger pageCount;
</span></span><span style=display:flex><span><span style=color:#66d9ef>@property</span> NSSet <span style=color:#f92672>*</span>categories;
</span></span><span style=display:flex><span><span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>getter</span> <span style=color:#f92672>=</span> isAvailable) <span style=color:#66d9ef>BOOL</span> available;
</span></span><span style=display:flex><span><span style=color:#66d9ef>@end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@implementation</span> <span style=color:#a6e22e>Book</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma mark - NSCoding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>- (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>initWithCoder:</span>(NSCoder <span style=color:#f92672>*</span>)decoder {
</span></span><span style=display:flex><span>    self <span style=color:#f92672>=</span> [super init];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>self) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> nil;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    self.title <span style=color:#f92672>=</span> [decoder decodeObjectForKey:<span style=color:#e6db74>@&#34;title&#34;</span>];
</span></span><span style=display:flex><span>    self.author <span style=color:#f92672>=</span> [decoder decodeObjectForKey:<span style=color:#e6db74>@&#34;author&#34;</span>];
</span></span><span style=display:flex><span>    self.pageCount <span style=color:#f92672>=</span> [decoder decodeIntegerForKey:<span style=color:#e6db74>@&#34;pageCount&#34;</span>];
</span></span><span style=display:flex><span>    self.categories <span style=color:#f92672>=</span> [decoder decodeObjectForKey:<span style=color:#e6db74>@&#34;categories&#34;</span>];
</span></span><span style=display:flex><span>    self.available <span style=color:#f92672>=</span> [decoder decodeBoolForKey:<span style=color:#e6db74>@&#34;available&#34;</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> self;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>encodeWithCoder:</span>(NSCoder <span style=color:#f92672>*</span>)encoder {
</span></span><span style=display:flex><span>    [encoder encodeObject:self.title forKey:<span style=color:#e6db74>@&#34;title&#34;</span>];
</span></span><span style=display:flex><span>    [encoder encodeObject:self.author forKey:<span style=color:#e6db74>@&#34;author&#34;</span>];
</span></span><span style=display:flex><span>    [encoder encodeInteger:self.pageCount forKey:<span style=color:#e6db74>@&#34;pageCount&#34;</span>];
</span></span><span style=display:flex><span>    [encoder encodeObject:self.categories forKey:<span style=color:#e6db74>@&#34;categories&#34;</span>];
</span></span><span style=display:flex><span>    [encoder encodeBool:[self isAvailable] forKey:<span style=color:#e6db74>@&#34;available&#34;</span>];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@end</span>
</span></span></code></pre></div><p>如上，<code>NSCoding</code> 主要是样板文件。每个属性用属性名作为key，编码或解码成一个对象或者类型。（有些开发者喜欢定义<code>NSString *</code>常量用作keypath, 其实通常这是没必要的）</p><p>但是在控制整个序列化过程中样板文件有时候也是非常有用的东西，它可以保持灵活，可以这样解释：</p><ul><li><p><strong>Migrations</strong>: 如果一个数据模型发生变化，如添加，重命名或删除一个字段，这应该与之前序列化的数据保持兼容性。Apple提供了一些参考<a href=https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/Archiving/Articles/compatibility.html%23//apple_ref/doc/uid/20001055-BCICFFGE>&ldquo;Forward and Backward Compatibility for Keyed Archives&rdquo;</a>.</p></li><li><p><strong>Archiving non-<code>NSCoding</code>-compatible Classes</strong>: 根据面向对象设计原则，对象应该可以被编码和解码成一种序列化的格式。但是如果一个类不是内置遵循<code>NSCoding</code>，你可以后续让这个类遵循<code>NSCoding</code>来达到目的。</p></li></ul><blockquote><p><a href=https://github.com/github/Mantle>Mantle</a>是一个意在减少写<code>NSCoding</code>样板文件的类库。如果你正在寻找更方便使用<code>NSCoding</code>代替Core Data创建model的方法，那Mantle值得一看。</p></blockquote><hr><p>当然，序列化只是故事的一部分。决定把数据持久化到什么地方又是另一个问题。同样，这里有两个方法：写入本地文件系统或者使用<code>NSUserDefaults</code>。</p><h2 id=file-system>File System</h2><p><code>NSKeyedArchiver</code> 和 <code>NSKeyedUnarchiver</code> 提供了很方便的API把对象读取/写入磁盘。</p><p>一个基于<code>NSCoding</code>的table view controller可以通过file manager设置它的属性集合。</p><h4 id=archiving>Archiving</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>[NSKeyedArchiver archiveRootObject:books toFile:<span style=color:#e6db74>@&#34;/path/to/archive&#34;</span>];
</span></span></code></pre></div><h4 id=unarchiving>Unarchiving</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>[NSKeyedUnarchiver unarchiveObjectWithFile:<span style=color:#e6db74>@&#34;/path/to/archive&#34;</span>];
</span></span></code></pre></div><h2 id=nsuserdefaults><code>NSUserDefaults</code></h2><p>每个应用程序都有自己的user preferences，它可以存储和检索遵循<code>NSCoding</code>协议的对象或者是C类型数据。</p><p>然而不推荐将整个对象图存入<code>NSUserDefaults</code>，但是用这种方式编码复合对象是不错的选择，例如“当前用户”的对象<del>或者API credentials</del><ins>(用 <a href=https://developer.apple.com/library/mac/#documentation/security/Conceptual/keychainServConcepts/iPhoneTasks/iPhoneTasks.html>Keychain</a> 来代替)</ins>。</p><h4 id=archiving-1>Archiving</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSData <span style=color:#f92672>*</span>data <span style=color:#f92672>=</span> [NSKeyedArchiver archivedDataWithRootObject:books];
</span></span><span style=display:flex><span>[[NSUserDefaults standardUserDefaults] setObject:data forKey:<span style=color:#e6db74>@&#34;books&#34;</span>];
</span></span></code></pre></div><h4 id=unarchiving-1>Unarchiving</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSData <span style=color:#f92672>*</span>data <span style=color:#f92672>=</span> [[NSUserDefaults standardUserDefaults] objectForKey:<span style=color:#e6db74>@&#34;books&#34;</span>];
</span></span><span style=display:flex><span>NSArray <span style=color:#f92672>*</span>books <span style=color:#f92672>=</span> [NSKeyedUnarchiver unarchiveObjectWithData:data];
</span></span></code></pre></div><hr><p>作为开发者，我们是有义务去理解我们应用程序的目标和需求，并且抑制住过于工程化和过早优化的冲动。</p><p>在应用程序中使用Core Data的决定或许是显而易见的。但是在很多情况下，Core Data 被发现是如此的笨拙或者不必要的，甚至是一种对可用性的障碍，更不用说实用性。</p><p>即使很多应用在某些方面_可能_受益于Core Data，让事物从简单演化到复杂是必要的，其中蕴含着智慧。但是就持久化而言，它不会比<code>NSCoding</code>更简单。</p><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2013-05-13 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mattt 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Cocoa target=_blank>Cocoa</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>