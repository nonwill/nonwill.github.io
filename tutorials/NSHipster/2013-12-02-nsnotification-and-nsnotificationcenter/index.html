<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>NSNotification & NSNotificationCenter</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="NSNotification & NSNotificationCenter,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="NSNotification & NSNotificationCenter,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>NSNotification & NSNotificationCenter</span><span class=btRight><span title="Author · 作者" class=author>Mattt</span> <span title="Translator · 翻译" class=author>Chester Liu</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p>思想的传播，与沟通的方式有着不可避免的联系。媒体对于信息重要性的影响是如此之大，以至于能够改变要传播的思想本身的含义。千真万确，媒体本身就是信息。</p><p>在社交中，首先要学习的一课，就是要知道你的受众。有些时候沟通是一对一的，例如两个人的对话。其他一些时候，沟通是一对多的，例如电视广播。如果不能区分这两种情况，可能会出现尴尬的场面。</p><p>同样的道理除了在人类中适用之外，也适用于计算机进程。在 Cocoa 中，对象之间的通信有很多办法，这些办法的亲近性和解耦程度各有不同：</p><table id=notification-center-coupling><thead><tr><td class=empty colspan=2 rowspan=2></td><th colspan=2>Audience</th></tr><tr><th>Intimate (One-to-One)</th><th>Broadcast (One-to-Many)</th></tr></thead><tbody><tr><th rowspan=2>Coupling</th><th>Loose</th><td><ul><li>Target-Action</li><li>Delegate</li><li>Callbacks</li></ul></td><td><ul><li><tt>Notifications</tt></li></ul></td></tr><tr><th>Strong</th><td><ul><li>Direct Method Invocation</li></ul></td><td><ul><li>Key-Value Observing</li></ul></td></tr></tbody></table><p>我们在 <a href=https://nshipster.cn/key-value-observing/>关于 Key-Value Observing</a> 的文章中探讨了通过 API 进行事件传递方式的重要性。这周，我们把视野放到其他的选择上，<code>NSNotificationCenter</code> 和 <code>NSNotification</code>。</p><hr><p><code>NSNotificationCenter</code> 提供了一个中心化的枢纽，通过它，应用的任何部分都可以向其他部分发送通知，或者接收来自别人的通知。观察者通过通知中心进行注册，对特定的事件注册特定的响应动作。每次这个事件发生时，通知经过分发表分发之后，会通知所有注册这个事件的观察者。</p><blockquote><p>每一个运行的 Cocoa 程序都有一个自己管理的默认通知中心，因此通常不会再单独实例化一个新的通知中心。</p></blockquote><blockquote><p>每个 <code>NSNotification</code> 对象都有一个 <code>name</code>，可以通过一个关联的 <code>object</code> 对象和 <code>userInfo</code> 字典来提供额外的上下文信息。</p></blockquote><p>举个例子，<code>UITextField</code> 在每次文本发生变化时，都会发出一个名为 <code>UITextFieldTextDidChangeNotification</code> 的 <code>NSNotification</code>。这个通知关联的对象就是文本框本身。对于 <code>UIKeyboardWillShowNotification</code> 这个通知来说，<code>userInfo</code> 中存入了 frame 的位置和动画时间，关联的 <code>object</code> 是 <code>nil</code>。</p><h3 id=添加观察者>添加观察者</h3><p>各种各样的通知车水马龙地通过 <code>NSNotificationCenter</code>。<sup>*</sup> 然而就像在树林中倒下的大树一样，一个通知本身不会有任何实际作用，除非有人在监听着它。</p><p>传统的添加观察者的方式是使用 <code>–addObserver:selector:name:object:</code>，一个对象（通常是 <code>self</code>）把自己添加进去，当某个通知发出时，执行自己特定的 selector。</p><p>现代的基于 Block 的用于添加通知观察者的 API 是 <code>–addObserverForName:object:queue:usingBlock:</code>。与前面提到的把一个已有的对象注册成观察者不同，这个方法创建一个匿名对象作为观察者，当收到对应的通知时，它在指定的队列（如果队列参数为 <code>nil</code> 的话就在调用者的线程）里执行一个 block。另外一点和基于 <code>@selector</code> 的方法不同的是，这个方法会返回构造出的观察者对象，在下个部分讲到的反注册的时候会用到它。</p><blockquote><p>和最近的一篇文章所声称的相反，<code>–addObserverForName:object:queue:usingBlock:</code> <em>不</em> 是有害处的用法。在应用中使用它是很安全的。只需要考虑 block 中引用到 <code>self</code> 时的内存管理问题就可以了。这方面需要考虑的问题和其他的 block 风格的 API 是一致的。</p></blockquote><p>上面提到的两个方法使用 <code>name</code> 和 <code>object</code> 这两个参数来确定通知是否符合观察者的需要。如果设置了 <code>name</code>，那么只有对应名称的通知会触发。如果设置成了 <code>nil</code>，那么 <em>所有</em> 的名称都会触发。同样的规则也适用于 <code>object</code>。如果同时设置了 <code>name</code> 和 <code>object</code> 那么只有来自特定对象的对应名称的通知才会响应。要是 <code>name</code> 和 <code>object</code> 都是 <code>nil</code>，那么 <em>所有</em> 的通知都会触发响应。</p><blockquote><p><sup>*</sup> 控制好你的代码！一个普通的 iOS 应用在启动之后的几秒钟内就会发出几十个通知，其中的大部分你可能都没有听说过，也不需要去关心。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> center = NSNotificationCenter.defaultCenter()
</span></span><span style=display:flex><span>center.addObserverForName(<span style=color:#66d9ef>nil</span>, object: <span style=color:#66d9ef>nil</span>, queue: <span style=color:#66d9ef>nil</span>) { notification <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\(</span>notification.name<span style=color:#e6db74>)</span><span style=color:#e6db74>: </span><span style=color:#e6db74>\(</span>notification.userInfo ?? [:]<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSNotificationCenter <span style=color:#f92672>*</span>center <span style=color:#f92672>=</span> [NSNotificationCenter defaultCenter];
</span></span><span style=display:flex><span>[center addObserverForName:nil
</span></span><span style=display:flex><span>                    object:nil
</span></span><span style=display:flex><span>                     queue:nil
</span></span><span style=display:flex><span>                usingBlock:<span style=color:#f92672>^</span>(NSNotification <span style=color:#f92672>*</span>notification)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>     NSLog(<span style=color:#e6db74>@&#34;%@&#34;</span>, notification.name);
</span></span><span style=display:flex><span>}];
</span></span></code></pre></div><h3 id=移除观察者>移除观察者</h3><p>在对象被释放之前移除掉观察者是很重要的，这样可以避免接受到之后的消息。</p><p>移除观察者有两个方法：<code>-removeObserver:</code> 和 <code>-removeObserver:name:object:</code>。和添加观察者类似，<code>name</code> 和 <code>object</code> 参数用来确定范围。使用 <code>-removeObserver:</code>，或者使用 <code>-removeObserver:name:object</code> 并把两个参数都设置成 <code>nil</code>，将会把观察者从通知中心的分发表当中彻底移除。通过 <code>-removeObserver:name:object:</code> 设置参数则只会移除注册对应的名称和/或对象的观察者。</p><h3 id=发送通知>发送通知</h3><p>当然，消费只是一个方面。除了订阅系统内置的通知之外，应用程序也可以自行发布和订阅通知。</p><p>通知通过 <code>+notificationWithName:object:userInfo:</code> 这个方法创建。</p><p>通知的名字通常定义为字符串常量。和其他字符串常量一样，应该在公共接口中使用 <code>extern</code> 声明，在实现中进行私有定义。具体的通知名称的值是什么没有太大的关系。变量本身的值是无关紧要的，当然使用可以反向 DNS 查询的标识符也是个不错的选择。只要通知的名称是唯一的（或者显式地指明别名），就能够得到我们想要的结果。</p><p>类似的，<code>userInfo</code> 里的键值也应该定义成字符串常量。应该在文档中清晰地注明哪个键对应哪种类型的值，因为编译器不能像针对对象那样对字典类型中的值类型进行限制。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FooController</span> : UIViewController {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Notifications</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>let</span> FooDidBar    = <span style=color:#e6db74>&#34;XXFooDidBarNotification&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>let</span> FooDidBazoom = <span style=color:#e6db74>&#34;XXFooDidBazoomNotification&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#75715e>// Foo.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>extern</span> NSString <span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> XXFooDidBarNotification;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Foo.m
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>NSString <span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> XXFooDidBarNotification <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;XXFooDidBarNotification&#34;</span>;
</span></span></code></pre></div><p>发送通知可以使用 <code>postNotificationName:object:userInfo:</code>，或者它的简化方法 <code>–postNotificationName:object:</code>，这个方法会自动把 <code>userInfo</code> 置为 <code>nil</code>。<code>–postNotification:</code> 这个方法也是存在的，不过通常建议把创建通知对象的过程交给系统方法去处理。</p><p>前面的部分中我们提到 <code>name</code> 和 <code>object</code> 用来控制通知分发的作用域。开发者们应当在对象发送通知和接收通知的方式上保持一致，而且把通知的行为在公共接口文档中进行清晰的说明。</p><p>由于通知分发是在发送通知的线程上进行的，可能需要使用 <code>dispatch_async</code> 和 <code>dispatch_get_main_queue()</code> 来保证通知的处理是在主线程进行。大部分情况下不需要考虑，不过还是要把这一点记在心里。</p><h2 id=kvo--nsnotificationcenter>KVO != NSNotificationCenter</h2><p>有一点经常让开发者们犯糊涂，<code>NSNotificationCenter</code> 的方法签名和 <a href=https://nshipster.cn/key-value-observing/>Key-Value Observing</a> 非常相似。</p><h4 id=key-value-observing>Key-Value Observing</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>addObserver</span>(observer: NSObject, forKeyPath keyPath: String,
</span></span><span style=display:flex><span>    options: NSKeyValueObservingOptions,
</span></span><span style=display:flex><span>    context: UnsafeMutablePointer&lt;Void&gt;)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>addObserver:</span>(NSObject <span style=color:#f92672>*</span>)observer
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>forKeyPath:</span>(NSString <span style=color:#f92672>*</span>)keyPath
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>options:</span>(NSKeyValueObservingOptions)options
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>context:</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)context
</span></span></code></pre></div><h4 id=nsnotificationcenter>NSNotificationCenter</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>addObserver</span>(observer: AnyObject,
</span></span><span style=display:flex><span>    selector aSelector: Selector,
</span></span><span style=display:flex><span>    name aName: String?,
</span></span><span style=display:flex><span>    object anObject: AnyObject?)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>addObserverForName</span>(name: String?,
</span></span><span style=display:flex><span>    object obj: AnyObject?,
</span></span><span style=display:flex><span>    queue: NSOperationQueue?,
</span></span><span style=display:flex><span>    usingBlock block: (NSNotification) -&gt; Void) -&gt; NSObjectProtocol
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>addObserver:</span>(<span style=color:#66d9ef>id</span>)notificationObserver
</span></span><span style=display:flex><span>           <span style=color:#a6e22e>selector:</span>(<span style=color:#66d9ef>SEL</span>)notificationSelector
</span></span><span style=display:flex><span>               <span style=color:#a6e22e>name:</span>(NSString <span style=color:#f92672>*</span>)notificationName
</span></span><span style=display:flex><span>             <span style=color:#a6e22e>object:</span>(<span style=color:#66d9ef>id</span>)notificationSender
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>addObserverForName:</span>(NSString <span style=color:#f92672>*</span>)name
</span></span><span style=display:flex><span>                  <span style=color:#a6e22e>object:</span>(<span style=color:#66d9ef>id</span>)obj
</span></span><span style=display:flex><span>                   <span style=color:#a6e22e>queue:</span>(NSOperationQueue <span style=color:#f92672>*</span>)queue
</span></span><span style=display:flex><span>              <span style=color:#a6e22e>usingBlock:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(NSNotification <span style=color:#f92672>*</span>))block
</span></span></code></pre></div><p><strong>Key-Value Observing 是在 keypaths 上添加观察者，而 NSNotificationCenter 是在通知上添加观察者。</strong> 牢记这个区别，就可以自信地去使用这两套 API 了。</p><hr><p>通知在应用内部的沟通中占有非常重要的地位。因为它的分布式，低耦合特性，通知适用于很多种架构设计。对于较大范围循环的重要事件添加通知，API 的表现也很好。性能上损耗可以忽略不计。</p><p>在人生中思考通知的意义，可以帮助你改善和其他人的关系。能够在沟通中展现自己的意图，以及给出必要的提醒，是一个成熟踏实的成年人的特征。</p><p>&mldr;但是不要过分采用这个建议并且把它作为直播自己生活的理由，或者任何东西的理由。说真的，别再拍照片了，赶紧吃你的饭吧，<em>我说的在理吧</em>？</p><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2013-12-02 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mattt 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Cocoa target=_blank>Cocoa</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>