<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>NSFastEnumeration / NSEnumerator</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="NSFastEnumeration / NSEnumerator,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="NSFastEnumeration / NSEnumerator,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>NSFastEnumeration / NSEnumerator</span><span class=btRight><span title="Author · 作者" class=author>Mattt</span> <span title="Translator · 翻译" class=author>Chester Liu</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p>遍历体现了计算能力的有趣之处。封装只执行一次的逻辑是一回事，把这个封装好的逻辑应用到集合当中的所有元素完全是另一回事了——这也正是计算机程序强大功能的一个体现。</p><p>每种编程范式都有自己遍历集合的方法：</p><ul><li><strong>过程式</strong> 在一个循环内进行指针自增</li><li><strong>面向对象</strong> 对集合内的所有对象都施加一个函数或者 block</li><li><strong>函数式</strong> 递归地处理数据结构</li></ul><p>作为本博客的主旨，Objective-C 语言扮演了一种神奇的桥接角色，在传统的 C 语言过程式编程和以 Smalltalk 为先驱的面向对象式编程之间架起了一座桥梁。从很多角度看来，遍历这部分的实现，是检验这座桥靠不靠谱的重要标准。</p><p>这篇文章将会涉及到 Objective-C & Cocoa 当中所有不同的遍历集合的方式。具体的方法有哪些呢？且听我慢慢道来。</p><hr><h2 id=c-循环forwhile>C 循环（<code>for/while</code>）</h2><p><code>for</code> 和 <code>while</code> 循环是遍历集合的“经典”方法。任何学过大学计算机基础的人都可以写出下面的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>for</span> (NSUInteger i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> [array count]; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>id</span> object <span style=color:#f92672>=</span> array[i];
</span></span><span style=display:flex><span>  NSLog(<span style=color:#e6db74>@&#34;%@&#34;</span>, object)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>但是用过 C 风格循环的人也都知道，这个方法容易导致 <a href=https://zh.wikipedia.org/wiki/%E5%B7%AE%E4%B8%80%E9%94%99%E8%AF%AF>差一错误</a>——特别是使用非标准形式时。</p><p>幸运的是，Smalltalk 使用一种叫做 <a href=https://en.wikipedia.org/wiki/List_comprehension>列表生成式</a> 的方法改善了这个问题，也就是大家今天所熟知的 <code>for/in</code> 循环。</p><h2 id=列表生成式-forin>列表生成式 （<code>for/in</code>）</h2><p>通过使用高层抽象，表明我们想遍历一个集合当中的所有元素，这种方法不仅减少了错误的发生，同时也减少了代码量：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>id</span> object <span style=color:#66d9ef>in</span> array) {
</span></span><span style=display:flex><span>    NSLog(<span style=color:#e6db74>@&#34;%@&#34;</span>, object);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 Cocoa 当中，生成式方法可以用在任何实现了 <code>NSFastEnumeration</code> 协议的类上，包括 <code>NSArray</code>, <code>NSSet</code>, 和 <code>NSDictionary</code>。</p><h3 id=nsfastenumeration><code>&lt;NSFastEnumeration></code></h3><p><code>NSFastEnumeration</code> 只包含一个方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>- (NSUInteger)<span style=color:#a6e22e>countByEnumeratingWithState:</span>(NSFastEnumerationState <span style=color:#f92672>*</span>)state
</span></span><span style=display:flex><span>                                  <span style=color:#a6e22e>objects:</span>(<span style=color:#66d9ef>id</span> <span style=color:#f92672>*</span>)stackbuf
</span></span><span style=display:flex><span>                                    <span style=color:#a6e22e>count:</span>(NSUInteger)len
</span></span></code></pre></div><blockquote><ul><li><code>state</code>: 遍历中需要使用的上下文信息，确保在遍历过程中集合不被修改。</li><li><code>stackbuf</code>: 一个 C 数组，内容是将要被调用者遍历的对象们.</li><li><code>len</code>: stackbuf 中最多能返回的元素数量.</li></ul></blockquote><p>一个 <em>看似很复杂</em> 的方法，里面有一个 <code>stackbuf</code> 指针出参，一个类型是 <code>NSFastEnumerationState *</code> 的 <code>state</code> 变量。我们来深入研究一下&mldr;</p><h3 id=nsfastenumerationstate><code>NSFastEnumerationState</code></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> state;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>id</span> <span style=color:#f92672>*</span>itemsPtr;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#f92672>*</span>mutationsPtr;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> extra[<span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span>} NSFastEnumerationState;
</span></span></code></pre></div><blockquote><ul><li><code>state</code>: 遍历器使用的一个状态信息，通常在遍历开始时这个值被设置成 0</li><li><code>itemsPtr</code>: 一个 C 对象数组</li><li><code>mutationsPtr</code>: 用于检测集合是否被修改的状态信息</li><li><code>extra</code>: 一个 C 数组，可以用来保存返回值</li></ul></blockquote><p>每个优雅的抽象背后，都是些注定要隐藏起来的实现。<code>itemPtr</code>？，<code>mutationsPtr</code>？<code>extra</code>？开玩笑吗，都是些什么东西？</p><blockquote><p>读者如果好奇的话，<a href=http://www.mikeash.com/pyblog/friday-qa-2010-04-16-implementing-fast-enumeration.html>Mike Ash 有一篇非常精彩的博客</a> ，在文章中他深入到了内部细节当中，提供了 <code>NSFastEnumeration</code> 若干参考实现。</p></blockquote><p>对于 <code>NSFastEnumeration</code> 你需要了解的是它 <em>很快</em> 。哪怕没有很明显的超过，也至少和你自己使用 <code>for</code> 循环是一样快的。高速背后的秘密是 <code>-countByEnumeratingWithState:objects:count:</code> 这个函数，它会缓存集合成员，并按需加载。和单线程的 <code>for</code> 循环实现不同的是，对象的加载是可以并发的，以最大程度利用系统资源。</p><p>苹果推荐在可能的情况下使用 <code>NSFastEnumeration</code> <code>for/in</code> 风格进行集合的遍历。老实说，单纯看它的用法是如此简单，性能表现也很好，这并不是个很难做出的选择。说真的，使用它吧。</p><h2 id=nsenumerator><code>NSEnumerator</code></h2><p>当然在 <code>NSFastEnumeration</code> 出现之前（大约是 OS X Leopard / iOS 2.0 时期），还有一位值得尊敬的先烈 <code>NSEnumerator</code>。</p><p>在外行人看来，<code>NSEnumerator</code> 是一个实现了下面两个方法的抽象类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>- (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>nextObject</span>
</span></span><span style=display:flex><span>- (NSArray <span style=color:#f92672>*</span>)<span style=color:#a6e22e>allObjects</span>
</span></span></code></pre></div><p><code>nextObject</code> 返回集合类型中的下一个元素，如果没有就返回 <code>nil</code>。<code>allObjects</code> 返回所有剩余的元素（如果有的话）。<code>NSEnumerator</code> 只能向一个方向遍历，而且只能进行单增。</p><p>要想遍历一个集合当中的所有元素，需要这样使用 <code>NSEnumerator</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>id</span> object <span style=color:#f92672>=</span> nil;
</span></span><span style=display:flex><span>NSEnumerator <span style=color:#f92672>*</span>enumerator <span style=color:#f92672>=</span> ...;
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> ((object <span style=color:#f92672>=</span> [enumerator nextObject])) {
</span></span><span style=display:flex><span>    NSLog(<span style=color:#e6db74>@&#34;%@&#34;</span>, object);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr;另外，为了跟上现在孩子们的脚步，<code>NSEnumerator</code> 本身也实现了 <code>&lt;NSFastEnumeration></code> 协议：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>id</span> object <span style=color:#66d9ef>in</span> enumerator) {
</span></span><span style=display:flex><span>    NSLog(<span style=color:#e6db74>@&#34;%@&#34;</span>, object);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果你想给自己的非集合支持的自定义类添加快速遍历功能的话，使用 <code>NSEnumerator</code> 可能是更加方便而且易用的方法，相比深入 <code>NSFastEnumeration</code> 的实现细节而言。</p><p>关于 <code>NSEnumeration</code> 几个有趣的小知识：</p><ul><li>使用一行代码实现数组反转（忽略"点"语法的过度使用）<code>array.reverseObjectEnumerator.allObjects</code>。</li><li>在 <a href=https://github.com/k06a/NSEnumeratorLinq><code>NSEnumeratorLinq</code></a> 的帮助下进行 LINQ 风格的操作，这个库使用了链式的 <code>NSEnumerator</code> 子类。</li><li>使用 <a href=https://github.com/mattt/TTTRandomizedEnumerator><code>TTTRandomizedEnumerator</code></a> 可以方便地随机取出集合当中的元素，又是一个第三方库，它支持使用随机顺序进行元素遍历。</li></ul><h2 id=使用-blocks-进行遍历>使用 Blocks 进行遍历</h2><p>最后，随着 OS X Snow Leopard / iOS 4 中 blocks 语法的引入，一种新的基于 block 的遍历集合的方法也被加入进来：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>[array enumerateObjectsUsingBlock:<span style=color:#f92672>^</span>(<span style=color:#66d9ef>id</span> object, NSUInteger idx, <span style=color:#66d9ef>BOOL</span> <span style=color:#f92672>*</span>stop) {
</span></span><span style=display:flex><span>    NSLog(<span style=color:#e6db74>@&#34;%@&#34;</span>, object);
</span></span><span style=display:flex><span>}];
</span></span></code></pre></div><p>诸如 <code>NSArray</code>, <code>NSSet</code>, <code>NSDictionary</code>，和 <code>NSIndexSet</code> 这些集合类型都包含了一系列类似的 block 遍历方法。</p><p>这种方法的一个优势是当前对象的索引 （<code>idx</code>）会跟随对象传递进来。<code>BOOL</code> 指针可以用于提前返回，相当于传统 C 循环当中的 <code>break</code> 语句。</p><p>除非你真的需要在遍历时使用数字索引，使用 <code>for/in</code> <code>NSFastEnumeration</code> 几乎总是更快的选择。</p><p>最后一个需要了解的是，这个系列方法还有带有 <code>options</code> 参数的扩展版本：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>enumerateObjectsWithOptions:</span>(NSEnumerationOptions)opts
</span></span><span style=display:flex><span>                         <span style=color:#a6e22e>usingBlock:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>id</span> obj, NSUInteger idx, <span style=color:#66d9ef>BOOL</span> <span style=color:#f92672>*</span>stop))block
</span></span></code></pre></div><h3 id=nsenumerationoptions><code>NSEnumerationOptions</code></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>enum</span> {
</span></span><span style=display:flex><span>   NSEnumerationConcurrent <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1UL</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>   NSEnumerationReverse <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1UL</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> NSUInteger NSEnumerationOptions;
</span></span></code></pre></div><blockquote><ul><li><code>NSEnumerationConcurrent</code>: 指示 Block 遍历应当是并发的。遍历的顺序是不确定而且未定义的；这个标志位是一个提示，可能在某些情况下会被实现方忽略；Block 中的代码必须在并发调用的情况下是安全的。</li></ul></blockquote><blockquote><ul><li><code>NSEnumerationReverse</code>: 指示遍历应该是反向进行的，这个选项在 <code>NSArray</code> 和 <code>NSIndexSet</code> 中可用；在 <code>NSDictionary</code> 和 <code>NSSet</code> 中，以及和 <code>NSEnumerationConcurrent</code> 同时使用的情况下，行为是未定义的。</li></ul></blockquote><p>再重申一次，快速遍历几乎可以肯定要比 block 遍历快很多，不过如果你被迫要使用 blocks 的话这些选项可能会有用。</p><hr><p>到现在，你已经了解到了 Objective-C 和 Cocoa 当中所以常见的遍历方法。</p><p>很有趣的一点是，当我们仔细研究这些方法时，我们能学习到抽象的重要性。高层的抽象不仅仅写起来方便，理解起来更容易，而且还往往比使用“困难的方法”要快。</p><p>高层命令会表明自己要达到的目的，例如“把这个集合当中的所有元素都遍历一遍”，它们把实现完全交给编译器进行高层优化，这一点通过传统的循环当中进行指针运算是完全做不到的。上下文是很强大的工具，根据上下文来设计 API 和功能，最终是为了实现抽象所承诺达到的目的：更容易地解决更大规模的问题。</p><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2013-07-01 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mattt 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Cocoa target=_blank>Cocoa</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>