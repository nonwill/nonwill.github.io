<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>Swift Literal Convertibles</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="Swift Literal Convertibles,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="Swift Literal Convertibles,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>Swift Literal Convertibles</span><span class=btRight><span title="Author · 作者" class=author>Mattt</span> <span title="Translator · 翻译" class=author>Chester Liu</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p>上周我们探讨了如何在 Swift 中 <a href=https://nshipster.cn/swift-operators/>重载和创建自定义操作符</a>，这个语言特性十分强大，同时也颇具争议。</p><p>从各方面来看，本周的文章也恐将两极分化，因为它的内容是 Swift 当中一个无处不在，然而又不被人注意的特性：字面值可转换性。</p><hr><p>在代码当中，一个 <em>字面值</em> 是一个固定值的表示。绝大部分语言都为一些基本类型定义了字面值，包括逻辑值，数字，字符串等，通常也有数组和字典。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> int = <span style=color:#ae81ff>57</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> float = <span style=color:#ae81ff>6.02</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> string = <span style=color:#e6db74>&#34;Hello&#34;</span>
</span></span></code></pre></div><p>字面值对于开发者而言，是编程时已经根深蒂固的一个概念，以至于我们当中的大多数人不会去主动思考编译器真正做了些什么（因此也并不了解类似 <a href=https://en.wikipedia.org/wiki/String_interning>字符串驻留</a> 等巧妙的技巧，一种幸福的无知）。</p><p>简单了解一下这些最基础的内容，有助于让代码变得更加好读好写。</p><p>在 Swift 中，通过 <em>字面值可转换协议（literal convertible protocols）</em> ，开发者可以控制通过字面值创建值的过程。</p><p>标准库定义了 10 个这种协议：</p><ul><li><code>ArrayLiteralConvertible</code></li><li><code>BooleanLiteralConvertible</code></li><li><code>DictionaryLiteralConvertible</code></li><li><code>ExtendedGraphemeClusterLiteralConvertible</code></li><li><code>FloatLiteralConvertible</code></li><li><code>NilLiteralConvertible</code></li><li><code>IntegerLiteralConvertible</code></li><li><code>StringLiteralConvertible</code></li><li><code>StringInterpolationConvertible</code></li><li><code>UnicodeScalarLiteralConvertible</code></li></ul><p>任意遵循了上面某个协议的 <code>class</code> 或 <code>struct</code> 都可以通过对应的字面值来静态初始化一个自己的实例。</p><p>这个特性使得字面值在整个语言中都能够玩得转。</p><p>以 optionals 做为例子。</p><h2 id=nilliteralconvertible-和-optionals>NilLiteralConvertible 和 Optionals</h2><p>有关 Swift 的 optionals 最好的一点就是，它的底层机制实际上是使用语言自身定义的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Optional</span>&lt;T&gt; : Reflectable, NilLiteralConvertible {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> None
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> Some(T)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>(<span style=color:#66d9ef>_</span> some: T)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>(nilLiteral: ())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>map</span>&lt;U&gt;(f: (T) -&gt; U) -&gt; U?
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getMirror</span>() -&gt; MirrorType
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意 <code>Optional</code> 遵循了 <code>NilLiteralConvertible</code> 接口：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>protocol</span> <span style=color:#a6e22e>NilLiteralConvertible</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>(nilLiteral: ())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>考虑下面两个语句：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>var</span> a: AnyObject = <span style=color:#66d9ef>nil</span> <span style=color:#75715e>// !</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> b: AnyObject? = <span style=color:#66d9ef>nil</span>
</span></span></code></pre></div><p><code>var a</code> 的声明会导致编译器报警 <code>Type 'AnyObject' does not conform to the protocol 'NilLiteralConvertible</code>，而 <code>var b</code> 的声明可以正常工作。</p><p>从底层看来，当一个字面值被赋值的时候，Swift 编译器查询对应的 <code>protocol</code>（在这里是 <code>NilLiteralConvertible</code>），然后调用对应的初始化器（<code>init(nilLiteral: ())</code>）。</p><p>尽管 <code>init(nilLiteral: ())</code> 的实现没有公开，最终的结果是，被设置为 <code>nil</code> 的 <code>Optional</code> 变成了 <code>.None</code>。</p><h2 id=stringliteralconvertible-和正则表达式>StringLiteralConvertible 和正则表达式</h2><p>Swift 字面值可转换性可以用来为自定义对象提供方便的快速初始化方法。</p><p>回忆一下我们上周的 <a href=https://nshipster.cn/swift-operators/><code>Regex</code></a> 例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Regex</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> pattern: String
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> options: NSRegularExpressionOptions!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> matcher: NSRegularExpression {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NSRegularExpression(pattern: <span style=color:#66d9ef>self</span>.pattern, options: <span style=color:#66d9ef>self</span>.options, error: <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>(pattern: String, options: NSRegularExpressionOptions = <span style=color:#66d9ef>nil</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>.pattern = pattern
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>.options = options
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>match</span>(string: String, options: NSMatchingOptions = <span style=color:#66d9ef>nil</span>) -&gt; Bool {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>self</span>.matcher.numberOfMatchesInString(string, options: options, range: NSMakeRange(<span style=color:#ae81ff>0</span>, string.utf16Count)) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>有 Ruby 和 Perl 背景的程序员可能会对 Swift 缺少正则表达式字面值感到失望，这个缺憾可以使用 <code>StringLiteralConvertible</code> 协议来弥补：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Regex</span>: StringLiteralConvertible {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>typealias</span> ExtendedGraphemeClusterLiteralType = StringLiteralType
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>(unicodeScalarLiteral value: UnicodeScalarLiteralType) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>.pattern = <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\(</span>value<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>(extendedGraphemeClusterLiteral value: ExtendedGraphemeClusterLiteralType) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>.pattern = value
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>(stringLiteral value: StringLiteralType) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>.pattern = value
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p><code>StringLiteralConvertible</code> 自身继承自 <code>ExtendedGraphemeClusterLiteralConvertible</code> 协议，这个协议又继承自 <code>UnicodeScalarLiteralConvertible</code>。<code>ExtendedGraphemeClusterLiteralType</code> 是表示长度为 1 的 <code>String</code> 的内部类型，<code>UnicodeScalarLiteralType</code> 是表示一个 <code>Character</code> 的数据类型。为了实现必要的 <code>init</code> 方法，<code>ExtendedGraphemeClusterLiteralType</code> 和 <code>UnicodeScalarLiteralType</code> 可以分别用 <code>typealias</code> 定义成别名 <code>StringLiteralType</code> 和 <code>Character</code>。</p></blockquote><p>现在我们可以这么做：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> string: String = <span style=color:#e6db74>&#34;foo bar baz&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> regex: Regex = <span style=color:#e6db74>&#34;foo&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>regex.match(string) <span style=color:#75715e>// true</span>
</span></span></code></pre></div><p>&mldr;或者更简单一些：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#e6db74>&#34;foo&#34;</span>.match(string) <span style=color:#75715e>// true</span>
</span></span></code></pre></div><p>和 <a href=https://nshipster.cn/swift-operators>自定义运算符 <code>=~</code></a> 结合起来，还可以写成更加符合习惯的语法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#e6db74>&#34;foo bar baz&#34;</span> =<span style=color:#f92672>~</span> <span style=color:#e6db74>&#34;foo&#34;</span> <span style=color:#75715e>// true</span>
</span></span></code></pre></div><hr><p>有些人可能会叹息，认为这个特性标志着代码可读性和可理解性的终结，另外一些人可能只是认为它弥补了这门新语言当中缺失的一部分。</p><p>主要问题还是在于你之前的习惯，以及你是否认同开发者有资格为语言添加特性，以更好地满足自己的需求。</p><blockquote><p>不管怎样，我希望我们都能认同一点——这个语言特性 <em>很有趣</em> ，而且值得深入挖掘。在这样的精神下，我们继续探索的路程，进一步展示更多的用例。</p></blockquote><hr><h2 id=arrayliteralconvertible-和-sets>ArrayLiteralConvertible 和 Sets</h2><p>作为一个对不可变性和安全性有着深刻要求的语言，Swift 的标准库当中并没有内建的集合类型支持，这多少有点奇怪。</p><p>数组很好用，我懂，但是却没有集合的 <code>O(1)</code> 复杂度查询和幂等性 &mldr; <em>*叹息声*</em></p><p>所以下面带来一个 <code>Set</code> 在 Swift 当中可能的实现，使用内置的 <code>Dictionary</code> 类型做为下层支持：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Set</span>&lt;T: Hashable&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>typealias</span> Index = T
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> dictionary: [T: Bool] = [:]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> count: Int {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>self</span>.dictionary.count
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> isEmpty: Bool {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>self</span>.dictionary.isEmpty
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>contains</span>(element: T) -&gt; Bool {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>self</span>.dictionary[element] ?? <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mutating</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>put</span>(element: T) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>.dictionary[element] = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mutating</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>remove</span>(element: T) -&gt; Bool {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>self</span>.contains(element) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>self</span>.dictionary.removeValueForKey(element)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>#         }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>一个实际使用的，标准库水平的 <code>Set</code> 实现带有的 Swift 风格特性会 <em>多出许多</em> ，例如生成器，序列和各种各样协议的行为。这些内容就足以单独写一篇文章来介绍了。</p></blockquote><p>当然，一个标准集合类型只有好用才显得有用。<code>NSSet</code> 运气并不好，没有受到一等公民的待遇，像数组和字典那样在 <a href=http://clang.llvm.org/docs/ObjectiveCLiterals.html>Apple LLVM Compiler 4.0</a> 当中加入对于字面值语法的支持，但是我们可以使用 <code>ArrayLiteralConvertible</code> 协议来纠正这个错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>protocol</span> <span style=color:#a6e22e>ArrayLiteralConvertible</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>typealias</span> Element
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>(arrayLiteral elements: Element...)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>扩展 <code>Set</code> 类型来遵循这个协议的做法很简明直接：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Set</span>: ArrayLiteralConvertible {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>init</span>(arrayLiteral elements: T...) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> element <span style=color:#66d9ef>in</span> elements {
</span></span><span style=display:flex><span>            put(element)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这就足够了，现在我们已经实现了想达到的效果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> set: Set = [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span><span style=color:#66d9ef>set</span>.contains(<span style=color:#ae81ff>1</span>) <span style=color:#75715e>// true</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>set</span>.count <span style=color:#75715e>// 3</span>
</span></span></code></pre></div><blockquote><p>然而这个例子也凸显了字面值可转换特性的一个值得担忧的地方：<strong>类型推导歧义</strong>。因为像 <code>Array</code> 和 <code>Set</code> 这样的集合类型之间有大量的 API 是重复的，很容易写出具有歧义的代码，即在类型不同时具有不同表现（例如，集合添加元素是幂等的，而数组则是增加的，因此添加两个相同的元素之后 count 的值会出现差异）。</p></blockquote><h2 id=stringliteralconvertible-和-urls>StringLiteralConvertible 和 URLs</h2><p>Alright, one last example creative use of literal convertibles: URL literals.</p><p>好了，最后一个富有创意的字面值可转换性用法：URL 字面值。</p><p><code>NSURL</code> 是 URL 加载系统的法定”通货“，它有优秀的符合 <a href=https://www.ietf.org/rfc/rfc2396.txt>RFC 2396</a> 的内部组件自省特性。不幸的是，它太难初始化了，以至于第三方框架的作者们往往选择放弃它，去使用差一些但是更加方便的字符串类型作为方法参数。</p><p>在 <code>NSURL</code> 上使用一个简单的扩展，就可以兼顾两者的好处了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>NSURL</span>: StringLiteralConvertible {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>func</span> convertFromExtendedGraphemeClusterLiteral(value: String) -&gt; <span style=color:#66d9ef>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>self</span>(string: value)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>func</span> convertFromStringLiteral(value: String) -&gt; <span style=color:#66d9ef>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>self</span>(string: value)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>字面值可转换性的另一个不错的特性是，类型推导甚至不需要变量定义也可以工作：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#e6db74>&#34;https://nshipster.com/&#34;</span>.host <span style=color:#75715e>// nshipster.com</span>
</span></span></code></pre></div><hr><p>作为社区中的一员，判断 Swift 的功能当中哪些是特性，哪些是 bug 正是我们的责任。我们来决定哪些设计是模式，哪些设计是反模式，哪些是惯例，哪些是危险用法。</p><p>诸如字面值可转换性，自定义操作符，和其它所有的 Swift 功能将来会如何协调工作，现在还尚不清晰。这个网站的文章在某些时候会对事情应该怎么做进行一些规定性的说明，但是对于这篇文章而言，并不是这种情况。</p><p>接下来要做的事情就是探索和学习。</p><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2014-08-18 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mattt 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Swift target=_blank>Swift</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>