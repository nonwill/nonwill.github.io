<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>WatchKit</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="WatchKit,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="WatchKit,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>WatchKit</span><span class=btRight><span title="Author · 作者" class=author>Mattt</span> <span title="Translator · 翻译" class=author>Bob Liu</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p><a href=https://apple.com/watch/>ᴡᴀᴛᴄʜ</a> 令每个人们兴奋。对于开发者来说更甚。</p><p>入门学习最好的方法是什么？只有 <a href=https://developer%E3%80%82apple.com/watchkit/>Apple&rsquo;s WatchKit developer resources</a>。</p><ul><li>观看 &ldquo;Getting Started&rdquo; 视频—就像是身处 Moscone（一个会展中心）。</li><li>阅读 <a href=https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/WatchHumanInterfaceGuidelines/index.html>Human Interface Guidelines</a>—考虑到它是你设计你程序的先决条件。</li><li>精读介绍此框架方方面面的 [WatchKit Programming Guide] (<a href=https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/WatchKitProgrammingGuide/index.html>https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/WatchKitProgrammingGuide/index.html</a>) 和<a href=https://developer.apple.com/library/prerelease/ios/samplecode/WKInterfaceCatalog/Introduction/Intro.html>WKInterfaceCatalog</a>。</li><li>当你最后准备给你的 app 增加对手表的拓展，查阅下 [Lister Sample App] (<a href=https://developer.apple.com/library/prerelease/ios/samplecode/Lister/Introduction/Intro.html>https://developer.apple.com/library/prerelease/ios/samplecode/Lister/Introduction/Intro.html</a>) (使用 Objective-C & Swift !)，看是如何在一起适配的。</li></ul><p>苹果开发者公共资源、开发布道活动、WatchKit 开发团队给 WatchKit 打好了基础。官方的资源是极好的。</p><p>即便如此，在阅读全部之后之后，由于与UIKit相关联，一些东西映入眼帘。他们主观、固执己见的东西不太好整理成文档，但是对于正在学习的人来说，可能是有趣或是有用的。</p><p>所以这周给大家介绍一个从 iOS 开发者的视角对于 WatchKit 的初步印象。</p><hr><p>当平台的制约成为限制开发者的角色的时候，WatchKit 倾听了最为早期的 iOS 开发。相比 OS X & AppKit 之前参差不齐的十年，iPhoneOS & UIKit 像一阵清风。Apps 也是小巧的、简单的、短小的。</p><p>在经历了7年时间和许多重大版本的发布，从 iPhones 和 iPads 的全部尺寸和形状到 TV 和 CarPlay ，iOS 已经成长到包含无数设备型号和配置了。这仍然是一个令开发者惊异的体验（大部分是这样的），但是感觉魔力也失去了前进的方向。</p><blockquote><p><strong>参照物</strong>： 回忆是不好的。 记得以前那些日子，没有 ARC，没有 GCD，没有 Interface Builder 对于 iOS 的支持，更加没有 Swift 。那段时间必不可少的开源库 Three20 和 asi-http-request 。那时候对于 tableview 的滑动展现的工艺水平是在 cell 的 contentView 调用 <code>drawRect:</code> 函数，手动的填上文字和图片。生活是孤独、贫穷、艰险、粗野和短暂的。</p></blockquote><p>不管你从哪里来，WatchKit 的简单将会令人愉悦和庆幸。</p><h2 id=和uikit相比较>和UIKit相比较</h2><p>考虑到可共享和分享的目标，WatchKit 具有和 UIKit 惊人的相似，这一点也不令人吃惊。手表不同于手机和平板电脑，他们放在桌面上并不相同。一些概念是可以共用的，但是每一个概念都会有自己独特的目的和限制，以形成他们自己的软件轮廓。</p><p>为了对比，这张表格怎么依据 UIKit / Cocoa 的概念去理解WatchKit。</p><table><thead><tr><th>WatchKit</th><th>UIKit</th></tr></thead><tbody><tr><td><code>WKInterfaceController</code></td><td><code>UIViewController</code></td></tr><tr><td><code>WKUserNotificationInterfaceController</code></td><td><code>UIApplicationDelegate</code> + <code>UIAlertController</code></td></tr><tr><td><code>WKInterfaceDevice</code></td><td><code>UIDevice</code></td></tr><tr><td><code>WKInterfaceObject</code></td><td><code>UIView</code></td></tr><tr><td><code>WKInterfaceButton</code></td><td><code>UIButton</code></td></tr><tr><td><code>WKInterfaceDate</code></td><td><code>UILabel</code> + <code>NSDateFormatter</code></td></tr><tr><td><code>WKInterfaceGroup</code></td><td><code>UIScrollView</code></td></tr><tr><td><code>WKInterfaceImage</code></td><td><code>UIImageView</code></td></tr><tr><td><code>WKInterfaceLabel</code></td><td><code>UILabel</code></td></tr><tr><td><code>WKInterfaceMap</code></td><td><code>MKMapView</code></td></tr><tr><td><code>WKInterfaceSeparator</code></td><td><code>UITableView.separatorColor</code> / <code>.separatorStyle</code></td></tr><tr><td><code>WKInterfaceSlider</code></td><td><code>UIStepper</code> + <code>UISlider</code></td></tr><tr><td><code>WKInterfaceSwitch</code></td><td><code>UISwitch</code></td></tr><tr><td><code>WKInterfaceTable</code></td><td><code>UITableView</code></td></tr><tr><td><code>WKInterfaceTimer</code></td><td><code>UILabel</code> + <code>NSDateFormatter</code> + <code>NSTimer</code></td></tr></tbody></table><blockquote><p>作为前缀 <a href=https://nshipster.com/namespacing/>namespace prefix</a>，<code>WKInterface</code> 别出心裁，但是 <code>WK</code> 是伴随新的 <a href=https://nshipster.com/wkwebkit/>WebKit</a>框架最近才发布的。尽管手表平台可以有网页还有很长一段路要走，但把他们区别开来的决定还是非常明智的。</p></blockquote><p>尽管有许多的重叠，但是也会有很多不同。理解这其中的区别既可以为如何将 WatchKit 做好提供资源信息，还可以教给我们苹果是如何思考 API 和时间可持续进步的。</p><h3 id=wkinterfacecontroller>WKInterfaceController</h3><p><code>WKInterfaceController</code> 在场景中管理元素， 然而 <code>UIViewController</code> 管理一个页面和他的子页面。 Interface objects 不是页面组， 但它缺扮演相似的角色。</p><p>为 <code>WKInterfaceController</code> 设计的初始化程序是 <code>initWithContext:</code>， 它接收 <code>context</code> 为参数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>init</span>(context: AnyObject?) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#66d9ef>init</span>(context: context)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>什么是 <code>context</code> ? 它是你想要的任何事情： 一个日期， 一个字符串， 一个数据模型，或者什么也不是。
<code>context</code> 的开放性一开始可能会让你迷惑，但是实际上它是对于 UIKit 长期存在问题提出来一种非常聪明的解决方式-即视图与控制器之间很难传递信息。在 <code>UIViewController</code> 被压栈，退栈，展出时候，没有一个标准统一的传递数值的方法，开发者经常遇见艰难的的选择，自定义初始器（不完全被Storyboards兼容），属性设定（容易创建控制伴随不完整的状态），自定义代理（如果做到正确，过于正式），或是用通知（额。。。不太好）。许多应用使用 Core Data 传递信息，通过在 App 代理里面存入其引用 <code>managedObjectContext</code> 的模型。</p><p>但是，我走题了。</p><p>总的来说， <code>WKInterfaceController</code> 的API不是那么有迹可循，但是没有比他的生命周期的方法更好说明的问题的了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// </span><span style=color:#75715e>MARK:</span><span style=color:#75715e> - WKInterfaceController</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>willActivate</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>didDeactivate</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>那正是想要的点：2个相互对应的方法。 No loading / unloading， no will / did appear / disappear， no <code>animated:YES</code> 。手表应用必然非常的简单。iOS 设备驱动应用和手表的通信都是耗时和耗电的，所有的交互控制器场景的初始化都是使用初始器和 <code>willActivate</code> 就全部完成了。 在执行<code>didDeactivate</code>之后，手表将会忽略页面内交互元素的更新。</p><p>手表的应用不是分层（Hierarchical）就是基于页面（Page-Based）。这就是熟悉的Xcode的工程模板，例如：&ldquo;Master-Detail Application&rdquo; ， &ldquo;Page-Based Application&rdquo; ， 和 &ldquo;Tabbed Application&rdquo; ，只可惜设计选项的被排除在外。</p><p>分层（Hierarchical）的应用里面有个隐藏的导航栈， <code>WKInterfaceController</code> 可以管理 <code>-pushControllerWithName:context:</code> 和 <code>-popController</code> 方法。需要注意一点是如何获取的字符串-在Storyboard里所指定的控制器的名称-而不是控制器实例本身。</p><p>另一方面，基于页面（Page-Based）的应用类似于可横向或者可纵向滚动的 <code>UIScrollView</code>，一些预先加载的场景都是用控制器来管理的。判断哪个使用场景最适合使用分层（Hierarchical）还是基于页面（Page-Based）的交互将会十分有趣。没有使用过真实的设备，仅凭猜想也没有太多的线索去了解。</p><p>最后一点，有一个有趣的例子使用的苹果的Swift简单代码，使用了内置结构体（inner structs）作为Storyboard的常量：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WatchListsInterfaceController</span>: WKInterfaceController<span style=color:#960050;background-color:#1e0010>，</span> ListsControllerDelegate {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>WatchStoryboard</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>let</span> interfaceControllerName = <span style=color:#e6db74>&#34;WatchListsInterfaceController&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>RowTypes</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>let</span> list = <span style=color:#e6db74>&#34;WatchListsInterfaceControllerListRowType&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>let</span> noLists = <span style=color:#e6db74>&#34;WatchListsInterfaceControllerNoListsRowType&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Segues</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>let</span> listSelection = <span style=color:#e6db74>&#34;WatchListsInterfaceControllerListSelectionSegue&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=wkinterfaceobject>WKInterfaceObject</h3><p><code>WKInterfaceObject</code> 好像 <code>UIView</code> 的翻译，包括属性 <code>alpha</code> ， <code>hidden</code> ， <code>horizontal</code> & <code>vertical</code> ，<code>alignment</code> ，和 <code>width</code> & <code>height</code>。</p><p>最显著的不同是没有了 <code>frame</code> 。 取而代之的是手动的指定坐标点和设置自动布局适应，WatchKit interface objects 在网隔里根据边缘和各自的顺序布局，就好像过去使用 CSS 的框架工作，好像<a href=http://getbootstrap.com>Bootstrap</a> (或者你是一名 Rubyists 还记得<a href=http://shoesrb.com>Shoes</a>吗?)。</p><p>另一些不同于 Cocoa Touch 是，<code>WKInterfaceObject</code> 使用对象-动作（ Target-Action ） 的方法对每个类型控制器来说只需要调用固定格式的方法，而不是动态的传递 <code>sender</code> 和 <code>UIEvent</code>。</p><table><thead><tr><th>Object</th><th>Action Method</th></tr></thead><tbody><tr><td>Button</td><td><code>- (IBAction)doButtonAction</code></td></tr><tr><td>Switch</td><td><code>- (IBAction)doSwitchAction:(BOOL)on</code></td></tr><tr><td>Slider</td><td><code>- (IBAction)doSliderAction:(float)value</code></td></tr><tr><td>Table</td><td><code>- (IBAction)doTableRowTapAction:(NSInteger)rowIndex</code></td></tr><tr><td>Menu Item</td><td><code>- (IBAction)doMenuItemAction</code></td></tr></tbody></table><p>为了更小， 关闭了控制器的状态集合， 这种方法更加的吸引人—比起输入 <code>UIControlEventTouchUpInside</code> 更加优秀。</p><h3 id=wkinterfacebutton>WKInterfaceButton</h3><p><code>WKInterfaceButton</code>是一个接口对象（interface object），它可以被点击来触发动作。它的可以包含是单一的文本标签或者是一组标签。</p><p>最新的部分更新的部分-有能力包含一个组-非常的_大_。这样避免了人们之前对 <code>UIButton</code> 的抱怨，它们使用起来非常困难，增加子视图和获得其视图位置以及正确的交互，致使人们只好放弃，并且去使用 <code>UITapGestureRecognizer</code>。</p><h3 id=wkinterfacetable>WKInterfaceTable</h3><p>所有从 iOS 中传来的概念中，列表可能是变化最大的。<code>UITableView</code> 是 iPhone 程序的支柱。因此，他们形成了相当复杂度去处理大量的应用数据需求，这些数据需要用各种方式去展现。相比之下<code>WKInterfaceTable</code>似乎另一番景象。</p><p>WatchKit 列表没有 sections 或者 headers， 或 footers， 或 editing， 或 searching， 或 data sources， 或 delegates。 行在<code>WKInterfaceController -willActivate</code> 方法之前被填充， 每行都有他自己对应的控制器(一个 <code>NSObject</code> 的子类和 一些<code>IBOutlet</code>)。 <code>WKInterfaceController</code>可以对列表的交互进行反馈，通过 <code>table:didSelectrowAtIndex:</code> 的代理方法，或者是用之前提供的对象-动作的方法`。</p><p>它可能看起来和之前十分不同，但是这种方法十分适合手表，并且相比 iOS 更加的直接。</p><h3 id=wkinterfacelabel>WKInterfaceLabel</h3><p>相比之下，<code>WKInterface</code> 可能是从iOS中变化最小的。支持 <code>NSAttributedString</code> ，自定义字体以及字体的尺寸，他几乎和你所能知道的一切一样的。</p><h3 id=wkinterfacedate--wkinterfacetimer>WKInterfaceDate & WKInterfaceTimer</h3><p>我们不会忘记对于手表时间是非常重要的概念。因此，WatchKit介绍了两个新的接口对象（interface object），他们在Cocoa 或者 Cocoa Touch 并先例：<code>WKInterfaceDate</code> 和 <code>WKInterfaceTimer</code> 。</p><p><code>WKInterfaceDate</code> 是一个特殊的标签，它用来展示目前的日期或是时间。<code>WKInterfaceTimer</code> 相似，除了它可以到指定日期并且倒计时。</p><p>以上两个类就像其他的 WatchKit 里面的类一样，确保了 app 的质量。考虑到这些任务对于手表的重要性，以及菜鸟程序员在运用 <code>NSDateFormatter</code> 和 <code>NSTimer</code> 时的情形，我们终于想象一下这些现象都消除了。</p><h3 id=wkinterfaceslider--wkinterfaceswitch>WKInterfaceSlider & WKInterfaceSwitch</h3><p>滑动条和开关应该在手表上回归。没有了触摸手势的福利，交互回归到基础。<em>Tap， Tap</em>， <code>On</code> / <code>Off</code>。 <em>Tap， Tap</em>， <code>+</code> / <code>-</code>。</p><p><code>WKInterfaceSlider</code> 和 <code>WKInterfaceSwitch</code> 便显出高水准和易自定义性。</p><hr><p>当然，以上文字只是对WatchKit浅显的思考。就像文章一开始我写到的，<a href=https://developer.apple.com/watchkit/>Apple&rsquo;s official resources for WatchKit</a>包括了任何你想到的事情。</p><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2014-12-01 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mattt 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Miscellaneous target=_blank>Miscellaneous</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>