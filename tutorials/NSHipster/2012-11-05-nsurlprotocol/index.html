<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>NSURLProtocol</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="NSURLProtocol,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="NSURLProtocol,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>NSURLProtocol</span><span class=btRight><span title="Author · 作者" class=author>Mattt</span> <span title="Translator · 翻译" class=author>Croath Liu</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p>iOS根本离不开网络——不论是从服务端读写数据、向系统分发计算任务，还是从云端加载图片、音频、视频等。</p><p>正因如此，Foundation库的<a href=https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html%23//apple_ref/doc/uid/10000165i>URL加载系统</a>是每个iOS工程师应该熟练掌握的。</p><p>当应用程序面临处理问题的抉择时，通常会选择最高级别的框架来解决这个问题。所以如果给定的任务是通过<code>http://</code>, <code>https://</code> 或 <code>ftp://</code>进行通讯，那么与 <code>NSURLConnection</code> 相关的方法就是最好的选择了。苹果关于网络的类涵盖甚广，包括从URL加载、缓存管理到认证与存储cookie等多个领域，完全可以满足现代Objective-C应用开发的需要：</p><figure id=url-loading-system><figcaption>URL加载系统</figcaption><table><thead><tr><td colspan=2><strong>URL加载</strong></td></tr></thead><tbody><tr><td colspan=2>NSURLConnection</td></tr><tr><td>NSURLRequest</td><td>NSMutableURLRequest</td></tr><tr><td>NSURLResponse</td><td>NSHTTPURLResponse</td></tr></tbody><thead><tr><td colspan=2><strong>缓存管理</strong></td></tr></thead><tbody><tr><td colspan=2>NSURLCache</td></tr><tr><td colspan=2>NSCacheURLRequest</td></tr><tr><td colspan=2>NSCachedURLResponse</td></tr></tbody><thead><tr><td colspan=2><strong>认证 & 证书</strong></td></tr></thead><tbody><tr><td colspan=2>NSURLCredential</td></tr><tr><td colspan=2>NSURLCredentialStorage</td></tr><tr><td colspan=2>NSURLAuthenticationChallenge</td></tr><tr><td colspan=2>NSURLProtectionSpace</td></tr></tbody><thead><tr><td colspan=2><strong>Cookie存储</strong></td></tr></thead><tbody><tr><td colspan=2>NSHTTPCookie</td></tr><tr><td colspan=2>NSHTTPCookieStorage</td></tr></tbody><thead><tr><td colspan=2><strong>协议支持</strong></td></tr></thead><tbody><tr><td colspan=2>NSURLProtocol</td></tr></tbody></table></figure><p>虽然URL加载系统包含的内容众多，但代码的设计上却非常良好，没有把复杂的操作暴露出来，开发者只需要在用到的时候进行设置。任何通过 <code>NSURLConnection</code> 进行的请求都会被系统的其他部分所拦截，这也使得当可用时显式地从硬盘加载缓存成为了可能。</p><p>说到这里，我们进入了本周的正题：<code>NSURLProtocol</code>。</p><hr><p><code>NSURLProtocol</code> 或许是URL加载系统中最功能强大但同时也是最晦涩的部分了。它是一个抽象类，你可以通过子类化来定义新的或已经存在的URL加载行为。</p><p>听了我说了这些乱七八糟的如果你还没有抓狂，这里有一些关于_希望加载请求时不用改变其他部分代码_的例子，供你参考：</p><ul><li><a href=http://stackoverflow.com/questions/5572258/ios-webview-remote-html-with-local-image-files>拦截图片加载请求，转为从本地文件加载</a></li><li><a href=http://www.infinite-loop.dk/blog/2011/09/using-nsurlprotocol-for-injecting-test-data/>为了测试对HTTP返回内容进行mock和stub</a></li><li>对发出请求的header进行格式化</li><li>对发出的媒体请求进行签名</li><li>创建本地代理服务，用于数据变化时对URL请求的更改</li><li>故意制造畸形或非法返回数据来测试程序的鲁棒性</li><li>过滤请求和返回中的敏感信息</li><li>在既有协议基础上完成对 <code>NSURLConnection</code> 的实现且与原逻辑不产生矛盾</li></ul><p>再次强调 <code>NSURLProtocol</code> 核心思想最重要的一点：用了它，你不必改动应用在网络调用上的其他部分，就可以改变URL加载行为的全部细节。</p><p>或者这么说吧： <code>NSURLProtocol</code> 就是一个苹果允许的中间人攻击。</p><h2 id=子类化nsurlprotocol>子类化NSURLProtocol</h2><p>之前提到过 <code>NSURLProtocol</code> 是一个抽象类，所以不能够直接使用必须被子类化之后才能使用。</p><h3 id=让子类识别并控制请求>让子类识别并控制请求</h3><p>子类化 <code>NSURLProtocol</code> 的第一个任务就是告诉它要控制什么类型的网络请求。比如说如果你想要当本地有资源的时候请求直接使用本地资源文件，那么相关的请求应该对应已有资源的文件名。</p><p>这部分逻辑定义在 <code>+canInitWithRequest:</code> 中，如果返回 <code>YES</code>，该请求就会被其控制。返回 <code>NO</code> 则直接跳入下一Protocol。</p><h3 id=提供请求规范>提供请求规范</h3><p>如果你想要用特定的某个方式来修改一个请求，应该使用 <code>+canonicalRequestForRequest:</code> 方法。每一个subclass都应该依据某一个规范，也就是说，一个protocol应该保证只有唯一的规范格式（虽然很多不同的请求可能是同一种规范格式）。</p><h3 id=获取和设置请求的属性>获取和设置请求的属性</h3><p><code>NSURLProtocol</code> 提供方法允许你来添加、获取、删除一个request对象的任意metadata，而且不需要私有扩展或者方法欺骗(swizzle)：</p><ul><li><code>+propertyForKey:inRequest:</code></li><li><code>+setProperty:forKey:inRequest:</code></li><li><code>+removePropertyForKey:inRequest:</code></li></ul><p>在操作protocol时对尚未赋予特定信息的 <code>NSURLRequest</code> 进行操作时，上述方法都是特别重要的。这些对于和其他方法之间的状态传递也非常有用。</p><h3 id=加载请求>加载请求</h3><p>你的子类中最重要的方法就是 <code>-startLoading</code> 和 <code>-stopLoading</code>。不同的自定义子类在调用这两个方法是会传入不同的内容，但共同点都是要围绕protocol客户端进行操作。</p><p>每个 <code>NSURLProtocol</code> 的子类实例都有一个 <code>client</code> 属性，该属性对URL加载系统进行相关操作。它不是 <code>NSURLConnection</code>，但看起来和一个实现了 <code>NSURLConnectionDelegate</code> 协议的对象非常相似。</p><h4 id=nsurlprotocolclient><code>&lt;NSURLProtocolClient></code></h4><ul><li><code>-URLProtocol:cachedResponseIsValid:</code></li><li><code>-URLProtocol:didCancelAuthenticationChallenge:</code></li><li><code>-URLProtocol:didFailWithError:</code></li><li><code>-URLProtocol:didLoadData:</code></li><li><code>-URLProtocol:didReceiveAuthenticationChallenge:</code></li><li><code>-URLProtocol:didReceiveResponse:cacheStoragePolicy:</code></li><li><code>-URLProtocol:wasRedirectedToRequest:redirectResponse:</code></li><li><code>-URLProtocolDidFinishLoading:</code></li></ul><p>在对 <code>-startLoading</code> 和 <code>-stopLoading</code> 的实现中，你需要在恰当的时候让 <code>client</code> 调用每一个delegate方法。简单来说就是连续调用那些方法，不过这是至关重要的。</p><h3 id=向url加载系统注册子类>向URL加载系统注册子类</h3><p>最后，为了使用 <code>NSURLProtocol</code> 子类，需要向URL加载系统进行注册。</p><p>当请求被加载时，系统会向每一个注册过的protocol询问：“Hey你能控制这个请求吗？”第一个通过 <code>+canInitWithRequest:</code> 回答为 <code>YES</code> 的protocol就会控制该请求。URL protocol会被以注册顺序的反序访问，所以当在 <code>-application:didFinishLoadingWithOptions:</code> 方法中调用 <code>[NSURLProtocol registerClass:[MyURLProtocol class]];</code> 时，你自己写的protocol比其他内建的protocol拥有更高的优先级。</p><hr><p>就像控制请求的URL加载系统一样， <code>NSURLProtocol</code> 也一样的无比强大，可以通过各种灵活的方式使用。它作为一个相对晦涩难解的类，我们挖掘出了它的潜力来让我们的代码更清爽健壮。</p><p>所以开始hack吧！我已经等不及看你们用它做出什么有趣的事情了！</p><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2012-11-05 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mattt 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Cocoa target=_blank>Cocoa</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>