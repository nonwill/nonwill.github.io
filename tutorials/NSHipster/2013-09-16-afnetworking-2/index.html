<!doctype html><html><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=.5"><title>AFNetworking 2.0</title>
<link rel="shortcut icon" type=image/x-icon href=/media/shortcuticon.png><meta name=keywords content="AFNetworking 2.0,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><meta name=description content="AFNetworking 2.0,macOS,C++,Cocoa,Objective-C,Swift,NSHipster"><script>if(document.domain=="autoptr.pages.dev"){var url=window.location.href,url=url.replace(/autoptr+\.pages+\.dev/g,"www.autoptr.top");window.location.href=url}</script><script src=/jscss/ajax/libs/anchor-js/4.2.0/anchor.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){anchors.options={visible:"hover",placement:"left",icon:"🌜"},anchors.add()})</script><link rel=stylesheet href=/css/main.css><link href=/jscss/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css rel=stylesheet><script src=/jscss/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><style type=text/css>body{background-color:#fbf6ec}</style><script>top.location!=self.location&&(top.location=self.location)</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?746e6e6d14d22526bf274c834750df53",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><script>window.addEventListener("resize",resizeThrottler,!1);var resizeTimeout;function resizeThrottler(){resizeTimeout||(resizeTimeout=setTimeout(function(){resizeTimeout=null,actualResizeHandler()},66))}actualResizeHandler();function actualResizeHandler(){/mobile/i.test(navigator.userAgent)||/android/i.test(navigator.userAgent)?document.body.classList.add("mobile"):document.body.classList.remove("mobile")}</script><a id=mysite-singlepage-top></a><div class=inner style=position:relative><div class=blog-post><h1 class=blog-title align=center><span class=btContent>AFNetworking 2.0</span><span class=btRight><span title="Author · 作者" class=author>Mattt</span> <span title="Translator · 翻译" class=author>Zihan Xu</span> <a href=https://github.com/NSHipster/articles-zh-Hans style=color:#007cd5 title="Related or Quoted Post · 关联或转载引用的文章" target=_blank rel="nofollow noopener noreferrer">&#128681;</a><a href=/tutorials/NSHipster/ title="Back to Topics · 回主题页">&#127793;</a></span></h1><p><a href=http://afnetworking.com>AFNetworking</a> 是当前 iOS 和 OS X
开发中最广泛使用的开源项目之一。它帮助了成千上万叫好又叫座的应用，也为其它出色的开源库提供了基础。这个项目是社区里最活跃、最有影响力的项目之一，拥有 8700 个 star、2200 个 fork 和 130 名贡献者。</p><p>从各方面来看，AFNetworking 几乎已经成为主流。</p><p><em>但你有没有听说过它的新版呢？</em>
<a href=https://github.com/AFNetworking/AFNetworking/>AFNetworking 2.0</a>。</p><p>这一周的 NSHipster：独家揭晓 AFNetworking 的未来。</p><blockquote><p>声明：NSHipster 由 <a href=https://twitter.com/mattt>AFNetworking 的作者</a> 撰写，所以这并不是对 AFNetworking 及它的优点的客观看法。你能看到的是个人关于 AFNetworking 目前及未来版本的真实看法。</p></blockquote><h2 id=afnetworking-的大体思路>AFNetworking 的大体思路</h2><p>始于 2011 年 5 月，AFNetworking 作为一个<a href=https://en.wikipedia.org/wiki/Gowalla>已死的 LBS 项目</a>中对 <a href=https://developer.apple.com/library/ios/samplecode/mvcnetworking/Introduction/Intro.html>Apple 范例代码</a>的延伸，它的成功更是由于时机。彼时 <a href=https://github.com/pokeb/asi-http-request>ASIHTTPRequest</a> 是网络方面的主流方案，AFNetworking 的核心思路使它正好成为开发者渴求的更现代的方案。</p><h3 id=nsurlconnection--nsoperation>NSURLConnection + NSOperation</h3><p><code>NSURLConnection</code> 是 Foundation URL 加载系统的基石。一个 <code>NSURLConnection</code> 异步地加载一个 <code>NSURLRequest</code> 对象，调用 delegate 的 <code>NSURLResponse</code> / <code>NSHTTPURLResponse</code> 方法，其 <code>NSData</code> 被发送到服务器或从服务器读取；delegate 还可用来处理 <code>NSURLAuthenticationChallenge</code>、重定向响应、或是决定 <code>NSCachedURLResponse</code> 如何存储在共享的 <code>NSURLCache</code> 上。</p><p><a href=https://nshipster.com/nsoperation><code>NSOperation</code></a> 是抽象类，模拟单个计算单元，有状态、优先级、依赖等功能，可以取消。</p><p>AFNetworking 的第一个重大突破就是将两者结合。<code>AFURLConnectionOperation</code> 作为 <code>NSOperation</code> 的子类，遵循 <code>NSURLConnectionDelegate</code> 的方法，可以从头到尾监视请求的状态，并储存请求、响应、响应数据等中间状态。</p><h3 id=blocks>Blocks</h3><p>iOS 4 引入的 block 和 Grand Central Dispatch 从根本上改善了应用程序的开发过程。相比于在应用中用 delegate 乱七八糟地实现逻辑，开发者们可以用 block 将相关的功能放在一起。GCD 能够轻易来回调度工作，不用面对乱七八糟的线程、调用和操作队列。</p><p>更重要的是，对于每个 request operation，可以通过 block 自定义 <code>NSURLConnectionDelegate</code> 的方法（比如，通过 <code>setWillSendRequestForAuthenticationChallengeBlock:</code> 可以覆盖默认的 <code>connection:willSendRequestForAuthenticationChallenge:</code> 方法）。</p><p>现在，我们可以创建 <code>AFURLConnectionOperation</code> 并把它安排进 <code>NSOperationQueue</code>，通过设置 <code>NSOperation</code> 的新属性 <code>completionBlock</code>，指定操作完成时如何处理 response 和 response data（或是请求过程中遇到的错误）。</p><h3 id=序列化--验证>序列化 & 验证</h3><p>更深入一些，request operation 操作也可以负责验证 HTTP 状态码和服务器响应的内容类型，比如，对于 <code>application/json</code> MIME 类型的响应，可以将 NSData 序列化为 JSON 对象。</p><p>从服务器加载 JSON、XML、property list 或者图像可以抽象并类比成潜在的文件加载操作，这样开发者可以将这个过程想象成一个 promise 而不是异步网络连接。</p><h2 id=介绍-afnetworking-20>介绍 AFNetworking 2.0</h2><p>AFNetworking 胜在易于使用和可扩展之间取得的平衡，但也并不是没有提升的空间。</p><p>在第二个大版本中，AFNetworking 旨在消除原有设计的怪异之处，同时为下一代 iOS 和 OS X 应用程序增加一些强大的新架构。</p><h3 id=动机>动机</h3><ul><li><p><strong>兼容 NSURLSession</strong> - <code>NSURLSession</code> 是 iOS 7 新引入的用于替代 <code>NSURLConnection</code> 的类。<code>NSURLConnection</code> 并没有被弃用，今后一段时间应该也不会，但是 <code>NSURLSession</code> 是 Foundation 中网络的未来，并且是一个美好的未来，因为它改进了之前的很多缺点。（参考 WWDC 2013 Session 705 “What’s New in Foundation Networking”，一个很好的概述）。起初有人推测，<code>NSURLSession</code> 的出现将使 AFNetworking 不再有用。但实际上，虽然它们有一些重叠，AFNetworking 还是可以提供更高层次的抽象。<strong>AFNetworking 2.0 不仅做到了这一点，还借助并扩展 <code>NSURLSession</code> 来铺平道路上的坑洼，并最大程度扩展了它的实用性。</strong></p></li><li><p><strong>模块化</strong> - 对于 AFNetworking 的主要批评之一是笨重。虽然它的构架使在类的层面上是模块化的，但它的包装并不允许选择独立的一些功能。随着时间的推移，<code>AFHTTPClient</code> 尤其变得不堪重负（其任务包括创建请求、序列化 query string 参数、确定响应解析行为、生成和管理 operation、监视网络可达性）。 <strong>在 AFNetworking 2.0 中，你可以挑选并通过 <a href=https://github.com/CocoaPods/CocoaPods/wiki/The-podspec-format#subspecs>CocoaPods subspecs</a> 选择你所需要的组件。</strong></p></li></ul><h3 id=演员阵容>演员阵容</h3><h4 id=nsurlconnection-组件-_ios-6--7_><code>NSURLConnection</code> 组件 <em>(iOS 6 & 7)</em></h4><ul><li><code>AFURLConnectionOperation</code> - <code>NSOperation</code> 的子类，负责管理 <code>NSURLConnection</code> 并且实现其 delegate 方法。</li><li><code>AFHTTPRequestOperation</code> - <code>AFURLConnectionOperation</code> 的子类，用于生成 HTTP 请求，可以区别可接受的和不可接受的状态码及内容类型。2.0 版本中的最大区别是，<strong>你可以直接使用这个类，而不用继承它</strong>，原因可以在“序列化”一节中找到。</li><li><code>AFHTTPRequestOperationManager</code> - 包装常见 HTTP web 服务操作的类，通过 <code>AFHTTPRequestOperation</code> 由 <code>NSURLConnection</code> 支持。</li></ul><h4 id=nsurlsession-组件-_ios-7_><code>NSURLSession</code> 组件 <em>(iOS 7)</em></h4><ul><li><code>AFURLSessionManager</code> - 创建、管理基于 <code>NSURLSessionConfiguration</code> 对象的 <code>NSURLSession</code> 对象的类，也可以管理 session 的数据、下载/上传任务，实现 session 和其相关联的任务的 delegate 方法。因为 <code>NSURLSession</code> API 设计中奇怪的空缺，<strong>任何和 <code>NSURLSession</code> 相关的代码都可以用 <code>AFURLSessionManager</code> 改善</strong>。</li><li><code>AFHTTPSessionManager</code> - <code>AFURLSessionManager</code> 的子类，包装常见的 HTTP web 服务操作，通过 <code>AFURLSessionManager</code> 由 <code>NSURLSession</code> 支持。</li></ul><hr><blockquote><p><strong>总的来说</strong>：为了支持新的 <code>NSURLSession</code> API 以及旧的未弃用且还有用的 <code>NSURLConnection</code>，AFNetworking 2.0 的核心组件分成了 request operation 和 session 任务。<code>AFHTTPRequestOperationManager</code> 和 <code>AFHTTPSessionManager</code> 提供类似的功能，在需要的时候（比如在 iOS 6 和 7 之间转换），它们的接口可以相对容易的互换。</p></blockquote><blockquote><p>之前所有绑定在 <code>AFHTTPClient</code>的功能，比如序列化、安全性、可达性，被拆分成几个独立的模块，可被基于 <code>NSURLSession</code> 和 <code>NSURLConnection</code> 的 API 使用。</p></blockquote><hr><h4 id=序列化>序列化</h4><p>AFNetworking 2.0 新构架的突破之一是使用序列化来创建请求、解析响应。可以通过序列化的灵活设计将更多业务逻辑转移到网络层，并更容易定制之前内置的默认行为。</p><ul><li><p><code>&lt;AFURLRequestSerializer></code> - 符合这个协议的对象用于处理请求，它将请求参数转换为 query string 或是 entity body 的形式，并设置必要的 header。那些不喜欢 <code>AFHTTPClient</code> 使用 query string 编码参数的家伙，你们一定喜欢这个。</p></li><li><p><code>&lt;AFURLResponseSerializer></code> - 符合这个协议的对象用于验证、序列化响应及相关数据，转换为有用的形式，比如 JSON 对象、图像、甚至基于 <a href=https://github.com/blog/1299-mantle-a-model-framework-for-objective-c>Mantle</a> 的模型对象。相比没完没了地继承 <code>AFHTTPClient</code>，现在 <code>AFHTTPRequestOperation</code> 有一个 <code>responseSerializer</code> 属性，用于设置合适的 handler。同样的，再也没有<a href=http://cocoadocs.org/docsets/AFNetworking/1.3.1/Classes/AFHTTPClient.html#//api/name/registerHTTPOperationClass:>没用的受 <code>NSURLProtocol</code> 启发的 request operation 类注册</a>，取而代之的还是很棒的 <code>responseSerializer</code> 属性。谢天谢地。</p></li></ul><h4 id=安全性>安全性</h4><p>感谢 <a href=https://github.com/dstnbrkr>Dustin Barker</a>、<a href=https://github.com/OliverLetterer>Oliver Letterer</a>、<a href=https://github.com/kcharwood>Kevin Harwood</a> 等人做出的贡献，AFNetworking 现在带有内置的 <a href=http://blog.lumberlabs.com/2012/04/why-app-developers-should-care-about.html>SSL pinning</a> 支持，这对于处理敏感信息的应用是十分重要的。</p><ul><li><code>AFSecurityPolicy</code> - 评估服务器对安全连接针对指定的固定证书或公共密钥的信任。tl;dr 将你的服务器证书添加到 app bundle，以帮助防止 <a href=https://en.wikipedia.org/wiki/Man-in-the-middle_attack>中间人攻击</a>。</li></ul><h4 id=可达性>可达性</h4><p>从 <code>AFHTTPClient</code> 解藕的另一个功能是网络可达性。现在你可以直接使用它，或者使用 <code>AFHTTPRequestOperationManager</code> / <code>AFHTTPSessionManager</code> 的属性。</p><ul><li><code>AFNetworkReachabilityManager</code> - 这个类监控当前网络的可达性，提供回调 block 和 notificaiton，在可达性变化时调用。</li></ul><h4 id=实时性>实时性</h4><ul><li><code>AFEventSource</code> - <a href=https://en.wikipedia.org/wiki/Server-sent_events><code>EventSource</code> DOM API</a> 的 Objective-C 实现。建立一个到某主机的持久 HTTP 连接，可以将事件传输到事件源并派发到听众。传输到事件源的消息的格式为 <a href=http://tools.ietf.org/html/rfc6902>JSON Patch</a> 文件，并被翻译成 <code>AFJSONPatchOperation</code> 对象的数组。可以将这些 patch operation 应用到之前从服务器获取的持久性数据集。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>NSURL <span style=color:#f92672>*</span>URL <span style=color:#f92672>=</span> [NSURL URLWithString:<span style=color:#e6db74>@&#34;http://example.com&#34;</span>];
</span></span><span style=display:flex><span>AFHTTPSessionManager <span style=color:#f92672>*</span>manager <span style=color:#f92672>=</span> [[AFHTTPSessionManager alloc] initWithBaseURL:URL];
</span></span><span style=display:flex><span>[manager GET:<span style=color:#e6db74>@&#34;/resources&#34;</span> parameters:nil success:<span style=color:#f92672>^</span>(NSURLSessionDataTask <span style=color:#f92672>*</span>task, <span style=color:#66d9ef>id</span> responseObject) {
</span></span><span style=display:flex><span>    [resources addObjectsFromArray:responseObject[<span style=color:#e6db74>@&#34;resources&#34;</span>]];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    [manager SUBSCRIBE:<span style=color:#e6db74>@&#34;/resources&#34;</span> usingBlock:<span style=color:#f92672>^</span>(NSArray <span style=color:#f92672>*</span>operations, NSError <span style=color:#f92672>*</span>error) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (AFJSONPatchOperation <span style=color:#f92672>*</span>operation <span style=color:#66d9ef>in</span> operations) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>switch</span> (operation.type) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> AFJSONAddOperationType:
</span></span><span style=display:flex><span>                    [resources addObject:operation.value];
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } error:nil];
</span></span><span style=display:flex><span>} failure:nil];
</span></span></code></pre></div><h4 id=uikit-扩展>UIKit 扩展</h4><p>之前 AFNetworking 中的所有 UIKit category 都被保留并增强，还增加了一些新的 category。</p><ul><li><code>AFNetworkActivityIndicatorManager</code>：在请求操作开始、停止加载时，自动开始、停止状态栏上的网络活动指示图标。</li><li><code>UIImageView+AFNetworking</code>：增加了 <code>imageResponseSerializer</code> 属性，可以轻松地让远程加载到 image view 上的图像自动调整大小或应用滤镜。比如，<a href=https://github.com/AFNetworking/AFCoreImageSerializer><code>AFCoreImageSerializer</code></a> 可以在 response 的图像显示之前应用 Core Image filter。</li><li><code>UIButton+AFNetworking</code> <em>(新)</em>：与 <code>UIImageView+AFNetworking</code> 类似，从远程资源加载 <code>image</code> 和 <code>backgroundImage</code>。</li><li><code>UIActivityIndicatorView+AFNetworking</code> <em>(新)</em>：根据指定的请求操作和会话任务的状态自动开始、停止 <code>UIActivityIndicatorView</code>。</li><li><code>UIProgressView+AFNetworking</code> <em>(新)</em>：自动跟踪某个请求或会话任务的上传/下载进度。</li><li><code>UIWebView+AFNetworking</code> <em>(新)</em>: 为加载 URL 请求提供了更强大的 API，支持进度回调和内容转换。</li></ul><hr><p>于是终于要结束 AFNetworking 旋风之旅了。为下一代应用设计的新功能，结合为已有功能设计的全新架构，有很多东西值得兴奋。</p><h3 id=旗开得胜>旗开得胜</h3><p>将下列代码加入 <a href=http://cocoapods.org><code>Podfile</code></a> 就可以开始把玩 AFNetworking 2.0 了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>platform <span style=color:#e6db74>:ios</span>, <span style=color:#e6db74>&#39;7.0&#39;</span>
</span></span><span style=display:flex><span>pod <span style=color:#e6db74>&#34;AFNetworking&#34;</span>, <span style=color:#e6db74>&#34;2.0.0&#34;</span>
</span></span></code></pre></div><p>For anyone coming over to AFNetworking from the current 1.x release, you may find <a href=https://github.com/AFNetworking/AFNetworking/wiki/AFNetworking-2.0-Migration-Guide>the AFNetworking 2.0 Migration Guide</a> especially useful.</p><p>对于由 AFNetworking 1.x 版本转移到新版本的用户，你可以找到 <a href=https://github.com/AFNetworking/AFNetworking/wiki/AFNetworking-2.0-Migration-Guide>AFNetworking 2.0 迁移指南</a>。</p><p>如果你遇到 bug 或者其它的奇怪的地方，请通过<a href="https://github.com/afnetworking/afnetworking/issues?state=open">在 GitHub 开启一个问题</a>来帮助我们改进。非常感谢您的帮助。</p><p>对于一般的使用问题，请随时 tweet 我 <a href=https://twitter.com/AFNetworking>@AFNetworking</a>，或者给我发邮件。</p><hr><p>除非<a href=https://nshipster.cn/ target=_blank>另有声明</a>，本文采用知识共享「<a href=https://creativecommons.org/licenses/by-nc/3.0/cn/ target=_blank>署名-非商业性使用 3.0 中国大陆</a>」许可协议授权。</p><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8922574795542092 data-ad-slot=2802455178 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer><p style="margin:0 -3px"><span style="float:left;margin:0 -3px"><a href=#mysite-singlepage-top title="Back to Top · 回顶部" rel=nofollow>&#127772;2013-09-16 </a>&copy;</span>
<span style="float:right;margin:0 -3px"><a href=https://autoptr.top/license/ title="Copyright &copy; All rights reserved" target=_blank rel=nofollow>&copy; 2025 Mattt 版权所有</a><a href=https://autoptr.top/ title="Back to Home · 回首页">&#127771;</a></span></p><hr><hr><p style="margin:3px 5px"><ul class=tags><span>标签:</span><li><a class=link href=https://autoptr.top/tags/C++ target=_blank>C++</a></li><li><a class=link href=https://autoptr.top/tags/nshipster target=_blank>nshipster</a></li><span>&nbsp;&nbsp;</span>
<span>分类:</span><li><a class=link href=https://autoptr.top/categories/Open%20Source target=_blank>Open Source</a></li><li><a class=link href=https://autoptr.top/categories/macOS target=_blank>macOS</a></li><li><a class=link href=https://autoptr.top/categories/CC++ target=_blank>CC++</a></li></ul><p style=margin-bottom:2em></p></p></footer></div><script src=/jscss/ajax/libs/jquery/3.3.1/jquery.slim.min.js></script><script src=/jscss/ajax/libs/twitter-bootstrap/3.1.1/js/bootstrap.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-37ZP0S1L3D"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-37ZP0S1L3D")</script><script src=/jscss/ajax/libs/medium-zoom/1.0.4/medium-zoom.min.js></script><script>const zoom=mediumZoom();zoom.attach("p img")</script></body></html>